<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SEO 搜索引擎优化</title>
      <link href="/2022/10/28/SEO%20%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/28/SEO%20%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索引擎工作原理"><a href="#搜索引擎工作原理" class="headerlink" title="搜索引擎工作原理"></a>搜索引擎工作原理</h1><p>1、<strong>SEO 概述</strong></p><p>让网站更加符合搜索引擎要求，从而得到搜索引擎的关键词排名，获得更多免费流量</p><p>2、<strong>工作原理</strong></p><p>抓取—收录建库预处理—分析搜索企求—对结果排序。</p><p>3、<strong>搜索引擎收录</strong></p><p>收录 = 抓取 + 收录建库预处理(网页数据库、索引数据库)</p><p>网页被搜索引擎蜘蛛爬行并保存索引，能被检索到时就算网页被收录了。</p><p>4、<strong>查询是否搜录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site: + 域名</span><br></pre></td></tr></table></figure><p>5、<strong>搜索引擎营销策略</strong></p><p>seo ：搜索引擎优化</p><p>sem ：搜索引擎优化营销</p><blockquote><p>seo 和 sem 的区别是：</p><p>1、seo 是指搜索引擎优化，sem 是指搜索引擎营销；</p><p>2、seo 只是对网站的优化，sem 是网站优化和付费营销两方面；</p><p>3、seo 对网站的优化时间较长，sem 优化较块，但不适合长久优化。</p></blockquote><ul><li>范围</li></ul><p>从它们两个范围上来讲的话，<code>SEO</code>是 <code>SEM</code> 其中的一部分，<code>SEO</code> 是包括在 <code>SEM</code> 里面的。<code>SEO</code> 只是对网站的优化，而 <code>SEM</code> 是网站优化和付费营销两个方面。</p><ul><li>费用方面</li></ul><p><code>SEO</code>是通过网站的自然排名来提高网站的权重，所以费用自然会低。</p><p><code>SEM</code>主要是通过付费手段来提高网站的权重，自然会比<code>SEO</code>费用要多。</p><h1 id="搜索引擎工具及平台"><a href="#搜索引擎工具及平台" class="headerlink" title="搜索引擎工具及平台"></a>搜索引擎工具及平台</h1><h2 id="SEO-查询工具"><a href="#SEO-查询工具" class="headerlink" title="SEO 查询工具"></a>SEO 查询工具</h2><p>1、Chinaz站长工具: <a href="http://seo.chinaz.com" target="_blank" rel="noopener">http://seo.chinaz.com</a><br>2、爱站网站长工具: <a href="https://www.aizhan.com/" target="_blank" rel="noopener">https://www.aizhan.com/</a></p><h2 id="搜索引擎官方平台工具"><a href="#搜索引擎官方平台工具" class="headerlink" title="搜索引擎官方平台工具"></a>搜索引擎官方平台工具</h2><p>1、百度资源搜索平台: <a href="https://ziyuan.baidu.com" target="_blank" rel="noopener">https://ziyuan.baidu.com</a><br>2、36o搜索站长平台: <a href="http://Zhanzhang.so.com" target="_blank" rel="noopener">http://Zhanzhang.so.com</a><br>3、搜狗搜索站长平台: <a href="http://Zhanzhang.sogou.com" target="_blank" rel="noopener">http://Zhanzhang.sogou.com</a> </p><h1 id="关键词以及分类"><a href="#关键词以及分类" class="headerlink" title="关键词以及分类"></a>关键词以及分类</h1><p>1、关键词定义</p><p>关键词，就是输入搜索框中的文字，也就是命令搜索引擎寻找的相关信息。</p><p>2、关键词分类</p><ul><li>按营销需求主辅分类：核心关键词、长尾关键词</li></ul><blockquote><ol><li>核心词<br>白内障治疗、白内障手术</li><li>长尾词<br>白内障的早期症状、眼睛干涩是怎么回事?、白内障手术大概多少钱?</li></ol></blockquote><p>3、关键词的选取</p><ul><li>头脑风暴</li><li>参照同行的 TDK</li><li>查询关键词热度（利用关键字挖掘工具）</li></ul><h1 id="seo-优化"><a href="#seo-优化" class="headerlink" title="seo 优化"></a>seo 优化</h1><h2 id="URL-优化和导航优化"><a href="#URL-优化和导航优化" class="headerlink" title="URL 优化和导航优化"></a>URL 优化和导航优化</h2><h3 id="URL-优化"><a href="#URL-优化" class="headerlink" title="URL 优化"></a>URL 优化</h3><p><code>URL</code>结构对于<code>SEO</code>很重要，因此在下载网站模板使用的时候务必进行修改，建议不要采用模板默认目录结构，可以把默认的栏目、子栏目的目录名称进行修改，这样就很大程度上保证网站<code>url</code>地址和其他网站的差异化。<code>URL</code>长度层级尽量控制在<code>3</code>层内。</p><h3 id="导航优化"><a href="#导航优化" class="headerlink" title="导航优化"></a>导航优化</h3><p>1、导航的分类名称最好用关键词分类，比如养羊站的导航分类：养羊技术、养羊视频、养羊成本和利润。以关键词为分类的导航更加有利于优化，因为栏目页的权重仅次于首页，而导航的链接是直接连接到栏目页的。</p><p>2、导航一定要使用文字形式，不能使用图片形式。搜索引擎暂时无法识别图片和 flash 等，而导航的链接是直接连接到栏目的，如果使用的是图片搜索引擎就不知道这个栏目在讲什么内容，那么给予这个栏目的关键词排名就更差。</p><p>3、面包屑导航。面包屑导航的作用是告诉用户所在的位置，提升网站的用户体验。</p><h2 id="TDK-优化"><a href="#TDK-优化" class="headerlink" title="TDK 优化"></a>TDK 优化</h2><p>1、标题<code>Title</code></p><p>用来定义网页标题的一个<code>html</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;网页标题1-网页标题2&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure><p><strong>标签注意事项</strong></p><ul><li>字符限制建议控制在80字符内</li><li>应添加本页面目标关键词</li></ul><p>2、描述<code>Description</code></p><p>功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;description  content&#x3D;&quot;页面描述&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>标签作用</strong>：对目标关键词的重要补充，对目标关键词相关搜索有排名辅助作用</p><p>3、关键词<code>Keywords</code></p><p>查看源代码才可以看到，<code>meta</code> 标签内添加页面关键词的一个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;关键词”&gt;</span><br></pre></td></tr></table></figure><p><strong>SEO 作用</strong>：用来调整关键词密度</p><h2 id="站内优化"><a href="#站内优化" class="headerlink" title="站内优化"></a>站内优化</h2><p>1、关键词布局、密度</p><p>布局：F 布局关键词</p><p>密度建议：2%-8%</p><p>2、网站内部结构优化</p><p><strong>优化网站结构</strong></p><ul><li>一般原则:<ul><li>用户在进行<code>3</code>次点击，可以到达网站的任何页面</li><li>搜索引擎抓取<code>3</code>级，抓取到网站的所有页面</li></ul></li></ul><p>3、内链优化与页面优化</p><p><strong>内链</strong></p><ul><li>跳转至相同域名下的网页链接</li></ul><p><strong>网站内页优化</strong></p><ul><li>四处一次<ul><li>title</li><li>meta（keywords、description）</li><li>内容（文章）</li><li>锚文本（超链接）</li></ul></li></ul><p><strong>网站内页优化作用</strong></p><ul><li>从连接上可以实现整个网站的有效衔接，进而实现用户体验和搜索引擎优化;</li><li>从文章质量上，可以有效的提高文章的用户体验度，进而提高用户粘度，有了这样的排名基石还愁什么。</li></ul><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>1、<code>&lt;h&gt;</code>标签</p><p>为了突出目标关键词，在使用b标签时应该注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;标签和&lt;h2&gt;标签，不建议同时使用</span><br><span class="line">&lt;h1&gt;标签和&lt;h2&gt;标签在使用的时候建议包含关键词</span><br><span class="line">&lt;h1&gt;标签和&lt;h2&gt;标签在使用的时候建议只出现一次</span><br><span class="line">&lt;h3&gt;、&lt;h4&gt; 、&lt;h5&gt; 标签SEO作用较小，建议不要乱用</span><br><span class="line">&lt;h6&gt; 可以用在首页友情链接处，以降低友情链接对页面目标关键词的影响</span><br></pre></td></tr></table></figure><p>2、<code>&lt;strong&gt;</code>标签</p><blockquote><p>标签注意事项<br>●页面内不要有大量的加粗文字<br>●页面内非关键词文本少用此标签<br>●一般网站标题都需要用此标签<br>●常用来标注文章小标题</p></blockquote><p>3、<code>&lt;img&gt;</code> 的 alt 属性</p><blockquote><p>注意事项<br>alt 描述要和图片内容相符<br>alt 描述控制在100字符内(极限)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经（Vue 部分）</title>
      <link href="/2022/10/23/%E9%9D%A2%E8%AF%95%EF%BC%88vue%20%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2022/10/23/%E9%9D%A2%E8%AF%95%EF%BC%88vue%20%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-3"><a href="#vue-3" class="headerlink" title="vue 3"></a>vue 3</h1><h2 id="ref-和-reactive"><a href="#ref-和-reactive" class="headerlink" title="ref 和 reactive"></a>ref 和 reactive</h2><p> <code>ref</code>需要注意的，<code>js</code>需要对<code>ref</code>定义的数据进行操作必须用 <code>变量.value</code>,例如下面的<code>color</code>，必须<code>color.value</code> ，而<code>reactive</code>创建的对象可以使用 <code>toRefs()</code>进行解构赋值。</p><h1 id="vue-2-和-vue-3-区别"><a href="#vue-2-和-vue-3-区别" class="headerlink" title="vue 2 和 vue 3 区别"></a>vue 2 和 vue 3 区别</h1><p>1、</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, toRefs, computed&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br></pre></td></tr></table></figure><p><code>vue3</code>要显示的引用，这样做的好处是按需引入，有利于性能优化（<code>tree shaking</code>可以摇掉不需要的模块，减小项目体积）</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 开发</title>
      <link href="/2022/10/09/uni-app/"/>
      <url>/2022/10/09/uni-app/</url>
      
        <content type="html"><![CDATA[<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a><center>uni-app</h1><h2 id="介绍项目目录和文件作用"><a href="#介绍项目目录和文件作用" class="headerlink" title="介绍项目目录和文件作用"></a>介绍项目目录和文件作用</h2><p>1、<code>pages.json</code>文件用来对<code>uni-app</code>进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生<code>tabBar</code>等；<br>2、<code>manifest.json</code>文件是应用的配置文件，用于指定应用的名称、图标、权限等；<br>3、<code>App.vue</code>是跟组件，所有页面都是在<code>App.vue</code>下进行切换的，是页面入口文件，可以调用应用的生命周期函数；<br>4、<code>main.js</code>是我们的项目入口文件，主要作用是初始化<code>vue</code>实例并使用需要的插件；<br>5、<code>uni.scss</code>文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，<code>uni.scss</code> 文件里预置了一些<code>SCSS</code>变量预置；<br>6、<code>unpackage</code>就是打包目录，在这里有各个平台的打包文件；<br>7、<code>pages</code>所有的页面存放目录；<br>8、<code>static</code> 静态资源目录，例如图片等；<br>9、<code>components</code>组件存放目录；</p><p>为了实现多端兼容，综合考虑编译速度、运行性能等因素，<code>uni-app</code>约定了如下开发规范:</p><ul><li>页面文件遵循<code>Vue</code>单文件组件(<code>SFC</code>)规范</li><li>组件标签靠近小程序规范，详见<code>uni-app</code>组件规范</li><li>接口能力(<code>JS API</code>)靠近微信小程序规范，但需将前缀<code>wx</code>替换为<code>uni</code>，详见<code>uni-app</code>接口规范</li><li>数据绑定及事件处理同<code>Vue.js</code>规范，同时补充了<code>App</code>及页面的生命周期</li><li>为兼容多端运行，建议使用<code>flex</code>布局进行开发</li></ul><h2 id="全局配置和页面配置"><a href="#全局配置和页面配置" class="headerlink" title="全局配置和页面配置"></a>全局配置和页面配置</h2><p>配置文件<code>pages.json</code>用来对<code>uni-app</code>进行全局配置文件，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生<code>tabBar</code>等；其中常用的属性如下：</p><ul><li>pages</li><li>globalStyle</li><li>tabBar</li><li>condition</li></ul><h3 id="globalStyle"><a href="#globalStyle" class="headerlink" title="globalStyle"></a>globalStyle</h3><p><code>globalStyle</code> 用于设置应用的状态栏、导航条、标题、窗口背景色等。</p><p>示例代码如下，<a href="https://uniapp.dcloud.net.cn/collocation/pages.html#globalstyle" target="_blank" rel="noopener">详情文档</a>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"globalStyle": &#123;</span><br><span class="line">"navigationBarTextStyle": "black",//页面导航 文字样式</span><br><span class="line">"navigationBarTitleText": "uni-app", //页面导航 title</span><br><span class="line">"navigationBarBackgroundColor": "#F8F8F8",</span><br><span class="line">"backgroundColor": "#F8F8F8"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>通过 <code>pages</code> 节点配置应用由哪些页面组成，<code>pages</code> 节点接收一个数组，数组每个项都是一个对象；</p><p>示例代码如下，<a href="https://uniapp.dcloud.net.cn/collocation/pages.html#pages" target="_blank" rel="noopener">详情文档</a>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pages"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"pages/index/index"</span>,</span><br><span class="line">            "style": &#123; ... &#125;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            "path": "pages/login/login",</span><br><span class="line">            "style": &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p>如果应用是一个多 <code>tab</code> 应用，可以通过 <code>tabBar</code> 配置项指定一级导航栏，以及 <code>tab</code> 切换时显示的对应页。</p><p>示例代码如下，<a href="https://uniapp.dcloud.net.cn/collocation/pages.html#tabbar" target="_blank" rel="noopener">详情文档</a>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"tabBar": &#123;</span><br><span class="line">"color": "#7A7E83",</span><br><span class="line">"selectedColor": "#3cc51f",</span><br><span class="line">"borderStyle": "black",</span><br><span class="line">"backgroundColor": "#ffffff",</span><br><span class="line">"list": [&#123;</span><br><span class="line">"pagePath": "pages/component/index",</span><br><span class="line">"iconPath": "static/image/icon_component.png",</span><br><span class="line">"selectedIconPath": "static/image/icon_component_HL.png",</span><br><span class="line">"text": "组件"</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"pagePath": "pages/API/index",</span><br><span class="line">"iconPath": "static/image/icon_API.png",</span><br><span class="line">"selectedIconPath": "static/image/icon_API_HL.png",</span><br><span class="line">"text": "接口"</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。</p><p>示例代码如下，<a href="https://uniapp.dcloud.net.cn/collocation/pages.html#condition" target="_blank" rel="noopener">详情文档</a>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"condition": &#123; //模式配置，仅开发期间生效</span><br><span class="line">"current": 0, //当前激活的模式（list 的索引项）</span><br><span class="line">"list": [&#123;</span><br><span class="line">"name": "swiper", //模式名称</span><br><span class="line">"path": "pages/component/swiper/swiper", //启动页面，必选</span><br><span class="line">"query": "interval=4000&amp;autoplay=false" //启动参数，在页面的onLoad函数里面得到。</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"test"</span>,</span><br><span class="line"><span class="attr">"path"</span>: <span class="string">"pages/component/switch/switch"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件的基本使用"><a href="#组件的基本使用" class="headerlink" title="组件的基本使用"></a>组件的基本使用</h2><p><code>uni-app</code>为开发者提供了一系列基础组件，类似<code>HTML</code>里的基础标签元素，但<code>uni-app</code>的组件与<code>HTML</code>不同，而是与小程序相同，更适合手机端使用。</p><ul><li>text；</li><li>view；类似 div 盒子</li><li>button；类似 button 按钮</li><li>image；类似 img</li></ul><h2 id="uni-app-中的样式"><a href="#uni-app-中的样式" class="headerlink" title="uni-app 中的样式"></a>uni-app 中的样式</h2><h3 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h3><p><code>rpx</code> 即响应式<code>px</code>，一种根据屏幕宽度自适应的动态单位。以<code>750</code>宽的屏幕为基准，<code>750 rpx</code>恰好为屏 幕宽度。屏幕变宽，<code>rpx</code> 实际显示效果会等比放大；</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">"./a.css"</span>);</span><br></pre></td></tr></table></figure><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>1、支持基本常用的选择器<code>class</code>、 <code>id</code>、 <code>element</code>等；</p><p>2、在<code>uni-app</code> 中不能使用<code>*</code>选择器；</p><p>3、<code>page</code>相当于<code>body</code>节点；</p><h3 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h3><p>定义在<code>App.vue</code>中的样式（<code>css</code>）为全局样式，作用于每一个页面。在<code>pages</code>目录下的<code>vue</code>文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖<code>App.vue</code>中相同的选择器。</p><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p><code>uni-app</code>支持使用字体图标，使用方式与普通<code>web</code>项目相同，需要注意以下几点：</p><ul><li>字体文件小于<code>40kb</code>，<code>uni-app</code>会自动将其转化为<code>base64</code>格式；</li><li>字体文件大于等于<code>40kb</code>， 需开发者自己转换，否则使用将不生效；</li><li>字体文件的引用路径推荐使用以<code>~@</code>开头的绝对路径。</li></ul><p>具体步骤：</p><p>（1）放入<code>iconfont</code>文件到项目文件到<code>static</code>文件夹下；</p><p>（2）<strong>全局</strong>/<strong>局部</strong>导入<code>iconfont</code>文件，并修改引用路径</p><p>导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">"./static/iconfont.css"</span>); <span class="comment">// `app.vue`或某个`vue`组件中</span></span><br></pre></td></tr></table></figure><p>引用路径：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: test1-icon;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'~@/static/iconfont.ttf'</span>)，</span><br><span class="line">     <span class="built_in">url</span>(<span class="string">'~@/static/iconfont.woff'</span>),</span><br><span class="line">     // ...</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用图标</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>= <span class="string">”iconfont</span> <span class="attr">icon-XXX</span>"&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用scss或less"><a href="#使用scss或less" class="headerlink" title="使用scss或less"></a>使用<code>scss</code>或<code>less</code></h3><p>1、下载插件</p><p>2、使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lang = “scss”</span><br></pre></td></tr></table></figure><p>3、配置</p><p>配置<code>uni.scss</code> 文件</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>在页面中需要定义数据，和我们之前的<code>vue</code>一样，直接在<code>data</code>中定义数据即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">'hello-uni'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插值表达式的使用</p><p>● 利用插值表达式渲染基本数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>● 在插值表达式中使用三元运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; flag ? ' 我是真的':'我是假的' &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>● 基本运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;1+1&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-bind-动态绑定属性"><a href="#v-bind-动态绑定属性" class="headerlink" title="v-bind 动态绑定属性"></a>v-bind 动态绑定属性</h3><p><code>v-bind</code>的缩写形式：<code>:</code></p><p>在<code>data</code>中定义了一张图片，我们希望把这张图片渲染到页面上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        imgUrl: <span class="string">'http://destiny001.gitee.io/image/monkey_02.jpg'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">:src</span>=<span class="string">"imgUrl"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="uni-中的事件"><a href="#uni-中的事件" class="headerlink" title="uni 中的事件"></a>uni 中的事件</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>在<code>uni</code>中事件绑定和<code>vue</code>中是一样的， 通过<code>v-on</code>进行事件的绑定，也可以简写为@</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;tapHandle&quot; &gt;点我啊&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>事件函数定义在<code>methods</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    tapHandle () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'真的点我了'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件传参<br>● 默认如果没有传递参数，事件函数第一个形参为事件对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// template</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"tapHandle"</span> &gt;</span>点我啊<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// script</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    tapHandle(e)&#123; <span class="comment">// e是事件对象</span></span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>● 如果传递参数，可以传递事件对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// template</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"tapHandle(1,$event)"</span> &gt;</span>点我啊<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// script</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    tapHandle(num,e)&#123; <span class="comment">// e是事件对象</span></span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(num,e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uni-生命周期"><a href="#uni-生命周期" class="headerlink" title="uni 生命周期"></a>uni 生命周期</h2><p>生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期；</p><p>生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数；</p><p>生命周期分为三类：应用、页面、组件生命周期：</p><h3 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h3><p>应用场景：进入微信，home 键跳出微信</p><p><a href="https://uniapp.dcloud.net.cn/collocation/App.html#applifecycle" target="_blank" rel="noopener">详情文件</a>，示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 只能在 App.vue 里监听应用的生命周期</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">onLaunch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'App Launch'</span>)  <span class="comment">//触发一次</span></span><br><span class="line">&#125;,</span><br><span class="line">onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'App Show'</span>)  <span class="comment">//可触发多次</span></span><br><span class="line">&#125;,</span><br><span class="line">onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'App Hide'</span>)  <span class="comment">//可触发多次</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>注意：只能在 <code>App.vue</code> 里监听应用的生命周期</p><h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><p><a href="https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle" target="_blank" rel="noopener">详细文档</a>，示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data() &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">    onLoad(options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'页面加载了'</span>, options)</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow() &#123; </span><br><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og( <span class="string">'页面显示了'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onReady()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'页面初次渲染完成了'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onHide() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'页面隐藏了'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件生命"><a href="#组件生命" class="headerlink" title="组件生命"></a>组件生命</h3><p>就是 <code>vue</code> 生命周期函数</p><table><thead><tr><th>周期函数</th><th>使用情况</th><th>其他建议</th></tr></thead><tbody><tr><td>beforeCreate</td><td></td><td></td></tr><tr><td>created</td><td>methods、data、props</td><td>发送请求</td></tr><tr><td>beforeMount</td><td>methods、data、props</td><td></td></tr><tr><td>mounted</td><td>methods、data、props、DOM</td><td></td></tr><tr><td>beforeUpdate</td><td></td><td></td></tr><tr><td>Updated</td><td></td><td></td></tr><tr><td>beforeDestroy</td><td></td><td></td></tr><tr><td>destroyed</td><td></td><td>清除定时器</td></tr></tbody></table><h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><p>存储浏览器或者应用的<code>Storage</code>去</p><h3 id="uni-setStorage-object"><a href="#uni-setStorage-object" class="headerlink" title="uni.setStorage(object)"></a>uni.setStorage(object)</h3><p>将数据存储在本地级存中指定的<code>key</code>中，会覆盖掉原来该<code>key</code>对应的内容，这是一个<strong>异步</strong>接口。</p><p><a href="https://uniapp.dcloud.net.cn/api/storage/storage.html#setstorage" target="_blank" rel="noopener">官方文档</a>，示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uni.setStorage(&#123;</span><br><span class="line">key: <span class="string">'storage_key'</span>,</span><br><span class="line">data: <span class="string">'hello'</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="uni-setStorageSync-key-data"><a href="#uni-setStorageSync-key-data" class="headerlink" title="uni.setStorageSync(key,data)"></a>uni.setStorageSync(key,data)</h3><p>将 <code>data</code> 存储在本地缓存中指定的 <code>key</code> 中，会覆盖掉原来该 <code>key</code> 对应的内容，这是一个<strong>同步</strong>接口。代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">    &lt;button type=<span class="string">"primary"</span> @click=<span class="string">"setStor"</span>&gt;存储数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>view&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        methods:&#123;</span></span><br><span class="line"><span class="regexp">            setstor()&#123;</span></span><br><span class="line"><span class="regexp">            try &#123;</span></span><br><span class="line"><span class="regexp">                    uni.setStorageSync('storage_key', 'hello');</span></span><br><span class="line"><span class="regexp">                &#125; catch (e) &#123;</span></span><br><span class="line"><span class="regexp">                    /</span><span class="regexp">/ error</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h3 id="uni-getStorage-object"><a href="#uni-getStorage-object" class="headerlink" title="uni.getStorage(object)"></a>uni.getStorage(object)</h3><p><a href="https://uniapp.dcloud.net.cn/api/storage/storage.html#getstorage" target="_blank" rel="noopener">详细文档</a>，代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uni.getStorage(&#123;</span><br><span class="line">key: <span class="string">'storage_key'</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res.data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="uni-getStorageSync-key"><a href="#uni-getStorageSync-key" class="headerlink" title="uni.getStorageSync(key)"></a>uni.getStorageSync(key)</h3><p><a href="https://uniapp.dcloud.net.cn/api/storage/storage.html#getstorage" target="_blank" rel="noopener">详细文档</a>，代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> value = uni.getStorageSync(<span class="string">'storage_key'</span>);</span><br><span class="line"><span class="keyword">if</span> (value) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uni-removeStorage-object"><a href="#uni-removeStorage-object" class="headerlink" title="uni.removeStorage(object)"></a>uni.removeStorage(object)</h3><p>从本地缓存中异步移除指定 <code>key</code>。</p><p><a href="https://uniapp.dcloud.net.cn/api/storage/storage.html#getstorage" target="_blank" rel="noopener">详细文档</a>，代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uni.removeStorage(&#123;</span><br><span class="line">key: <span class="string">'storage_key'</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="uni-removeStorageSync-key"><a href="#uni-removeStorageSync-key" class="headerlink" title="uni.removeStorageSync(key)"></a>uni.removeStorageSync(key)</h3><p>从本地缓存中同步移除指定 <code>key</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">uni.removeStorageSync(<span class="string">'storage_key'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传图片、预览图片"><a href="#上传图片、预览图片" class="headerlink" title="上传图片、预览图片"></a>上传图片、预览图片</h2><h3 id="uni-chooseImage-object"><a href="#uni-chooseImage-object" class="headerlink" title="uni.chooseImage(object)"></a>uni.chooseImage(object)</h3><p>上传图片，<code>uni.chooseImage</code>方法从本地相册选择图片或使用相机拍照。<a href="https://uniapp.dcloud.net.cn/api/media/image.html#chooseimage" target="_blank" rel="noopener">详细案例</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uni.chooseImage(&#123;</span><br><span class="line">count: <span class="number">6</span>, <span class="comment">//默认9</span></span><br><span class="line">sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>], <span class="comment">//可以指定是原图还是压缩图，默认二者都有</span></span><br><span class="line">sourceType: [<span class="string">'album'</span>], <span class="comment">//从相册选择</span></span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res.tempFilePaths));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="uni-previewImage-object"><a href="#uni-previewImage-object" class="headerlink" title="uni.previewImage(object)"></a>uni.previewImage(object)</h3><p>预览图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从相册选择6张图</span></span><br><span class="line">uni.chooseImage(&#123;</span><br><span class="line">count: <span class="number">6</span>,</span><br><span class="line">sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>],</span><br><span class="line">sourceType: [<span class="string">'album'</span>],</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 预览图片</span></span><br><span class="line">uni.previewImage(&#123;</span><br><span class="line">urls: res.tempFilePaths,</span><br><span class="line">longPressActions: &#123;</span><br><span class="line">itemList: [<span class="string">'发送给朋友'</span>, <span class="string">'保存图片'</span>, <span class="string">'收藏'</span>],</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'选中了第'</span> + (data.tapIndex + <span class="number">1</span>) + <span class="string">'个按钮,第'</span> + (data.index + <span class="number">1</span>) + <span class="string">'张图片'</span>);</span><br><span class="line">&#125;,</span><br><span class="line">fail: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.errMsg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上传并展示图片，案例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"chooseImg” type="</span>primary<span class="string">"&gt; 上传图片&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;view&gt;</span></span><br><span class="line"><span class="string">        &lt;image v-for="</span>item <span class="keyword">in</span> imgArr” :src=<span class="string">"item"</span> :key=<span class="string">"index"</span> @click=<span class="string">"previewImg(item)"</span>&gt;&lt;<span class="regexp">/image&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>view&gt;</span><br><span class="line">    &lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">            imgArr:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            chooseImg() &#123;</span><br><span class="line">                uni.chooseImage(&#123;</span><br><span class="line">                    count: <span class="number">9</span>,</span><br><span class="line">                    success: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">this</span>.imgArr = res.tempFilepaths</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">            previewImg(current) &#123;</span><br><span class="line">                uni.previewImage(&#123;</span><br><span class="line">                    current,</span><br><span class="line">                    urls:<span class="keyword">this</span>.imgArr</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="条件注释实现跨段兼容"><a href="#条件注释实现跨段兼容" class="headerlink" title="条件注释实现跨段兼容"></a>条件注释实现跨段兼容</h2><p><a href="https://uniapp.dcloud.net.cn/tutorial/platform.html#%E8%B7%A8%E7%AB%AF%E5%85%BC%E5%AE%B9" target="_blank" rel="noopener">详细文档</a></p><p>条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。</p><p>语法：</p><p>以<code>#ifdef</code>加平台标识开头，以<code>#endif</code>结尾，</p><p>1、页面模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  #ifdef  &lt;平台值&gt; --&gt;</span></span><br><span class="line">代码...</span><br><span class="line"><span class="comment">&lt;!--  #endif --&gt;</span></span><br></pre></td></tr></table></figure><p>2、js 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef  &lt;平台值&gt; </span></span><br><span class="line">    代码...</span><br><span class="line"><span class="comment">//  #endif</span></span><br></pre></td></tr></table></figure><p>3、css 样式中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #ifdef  &lt;平台值&gt;  */</span></span><br><span class="line">    代码...</span><br><span class="line"><span class="comment">/*  #endif   */</span></span><br></pre></td></tr></table></figure><p>平台对应表：</p><table><thead><tr><th>值</th><th>平台</th></tr></thead><tbody><tr><td>APP-PLUS</td><td>5+App</td></tr><tr><td>H5</td><td>H5</td></tr><tr><td>MP-WEIXIN</td><td>微信小程序</td></tr><tr><td>MP-ALIPAY</td><td>支付宝小程序</td></tr><tr><td>MP-BAIDU</td><td>百度小程序</td></tr><tr><td>MP-TOUTIAO</td><td>头条小程序</td></tr><tr><td>MP-QQ</td><td>QQ 小程序</td></tr><tr><td>MP</td><td>微信小程序/支付宝小程序/百度小程序/头条小程序/QQ 小程序</td></tr></tbody></table><h2 id="uni-中的导航跳转"><a href="#uni-中的导航跳转" class="headerlink" title="uni 中的导航跳转"></a>uni 中的导航跳转</h2><h3 id="利用navigator进行跳转"><a href="#利用navigator进行跳转" class="headerlink" title="利用navigator进行跳转"></a>利用<code>navigator</code>进行跳转</h3><p><code>navigator</code>详细文档：<a href="https://uniapp.dcloud.net.cn/component/navigator.html#navigator" target="_blank" rel="noopener">文档地址</a></p><p>1、跳转到<strong>普通</strong>页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">ur1</span>=<span class="string">"/pages/ about/ about"</span> <span class="attr">hover-class</span>=<span class="string">"navigator-hover"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"default"</span> &gt;</span>跳转到关于页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、跳转到<code>tabBar</code>页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">ur1</span>=<span class="string">"/pages/message/message"</span> <span class="attr">open-</span> <span class="attr">type</span>=<span class="string">" switchTab"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"default"</span> &gt;</span>跳转到message页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用编程式导航进行跳转"><a href="#利用编程式导航进行跳转" class="headerlink" title="利用编程式导航进行跳转"></a>利用编程式导航进行跳转</h3><blockquote><p>注意：跳转到 tabBar 页面只能使用 switchTab 跳转</p></blockquote><p>常见的几个导航<code>API</code>如下</p><p>1、<code>uni.navigateTo</code></p><p>保留当前页面，跳转到应用内的某个页面，使用<code>uni .navigateBack</code>可以返回到原页面。<a href="https://uniapp.dcloud.net.cn/api/router.html#navigateto" target="_blank" rel="noopener">详细文档</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"goAbout"</span> &gt;</span>跳转到关于页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>navigateTo</code>方法进行跳转到普通页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goAbout () &#123;</span><br><span class="line">    uni.navigateTo(&#123;</span><br><span class="line">        url: <span class="string">'/pages/about/about'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、<code>uni.switchTab</code></p><p>跳转到 <code>tabBar</code> 页面，并关闭其他所有非 <code>tabBar</code>页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.switchTab(&#123;</span><br><span class="line">url: <span class="string">'/pages/index/index'</span>  <span class="comment">// 其他页面的 unload 会被调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、<code>uni.redirectTo(object)</code></p><p>关闭当前页面，跳转到应用内的某个页面。<a href="https://uniapp.dcloud.net.cn/api/router.html#redirectto" target="_blank" rel="noopener">详细文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.redirectTo(&#123;</span><br><span class="line">url: &#39;test?id&#x3D;1&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="跳转传参"><a href="#跳转传参" class="headerlink" title="跳转传参"></a>跳转传参</h3><p>传递参数页面</p><p>导航页面 1：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">ur1</span>=<span class="string">"/pages/message/message?id=4&amp;age=3"</span> <span class="attr">open-</span> <span class="attr">type</span>=<span class="string">" switchTab"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"default"</span> &gt;</span>跳转到message页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导航页面 2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goAbout () &#123;</span><br><span class="line">    uni.navigateTo(&#123;</span><br><span class="line">    url: <span class="string">'/pages/about/about?id=80'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参数接收：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        onLoad (options) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(options)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h2><h3 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h3><p>在<code>uni-app</code>中，可以通过创建一个后缀名为<code>vue</code>的文件，即创建一个组件成功，其他组件可以将该组件通过<code>impot</code>的方式导入，在通过<code>components</code>进行注册即可.</p><p>● 创建<code>login</code>组件， 在<code>component</code>中创建<code>login</code>目录，然后新建<code>login.vue</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">    <span class="comment">// 这是一个自定义组件</span></span><br><span class="line">    &lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>● 在其他组件中导入该组件并注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">"@/components/test/test.vue"</span></span><br></pre></td></tr></table></figure><p>● 注册组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;test&#125;</span><br></pre></td></tr></table></figure><h3 id="组件的通讯"><a href="#组件的通讯" class="headerlink" title="组件的通讯"></a>组件的通讯</h3><p>1、父组件给子组件传值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">:msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">"@/components/test/test.vue"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">            msg: <span class="string">'hello'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;test&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>props</code>接受外界传递到组件内部的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 子组件：test </span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        // 接收参数</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    props: [<span class="string">'msg'</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、子组件给父组件传值</p><p>通过<code>$emit</code>触发自定义事件进行传递参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 子组件：test </span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    这是一个自定义组件&#123;&#123;msg&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"sendMsg"</span>&gt;</span>给父组件传值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            status: <span class="string">'打篮球'</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            msg: &#123;</span><br><span class="line"><span class="javascript">                type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="actionscript">                value:<span class="string">''</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sendMsg () &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.$emit(<span class="string">'myEvent'</span>,<span class="keyword">this</span>.status)</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过组件标签传值，<code>methods</code>定义方法接收数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        // 子组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> @<span class="attr">myEvent</span>=<span class="string">"getMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            msg: <span class="string">''</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            getMsg(value) &#123;</span><br><span class="line"><span class="actionscript">               <span class="keyword">this</span>.msg= value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、组件间传值</p><p><a href="https://uniapp.dcloud.net.cn/api/window/communication.html#emit" target="_blank" rel="noopener">详细文档</a></p><ul><li><code>uni.$emit(eventName,object)</code>，触发全局的自定义事件，附加参数都会传给监听器回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发某个 methods 函数</span><br><span class="line">uni.$emit(&#39;update&#39;,&#123;msg:&#39;页面更新&#39;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>uni.$on(eventName,callback)</code>，监听全局的自定义事件，事件由 <code>uni.$emit</code> 触发，回调函数会接收事件触发函数的传入参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; create() 函数内部调用</span><br><span class="line">uni.$on(&#39;update&#39;,function(data)&#123;</span><br><span class="line">console.log(&#39;监听到事件来自 update ，携带参数 msg 为：&#39; + data.msg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 入门</title>
      <link href="/2022/10/04/TS/"/>
      <url>/2022/10/04/TS/</url>
      
        <content type="html"><![CDATA[<h1 id="TS-基本类型"><a href="#TS-基本类型" class="headerlink" title="TS 基本类型"></a>TS 基本类型</h1><p>指定变量的类型，使得变量只存储某种类型的值</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量: 类型;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 变量: 类型 = 值;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">参数: 类型, 参数: 类型</span>): 类型</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h2><p>（1）<code>TS</code>拥有自动的类型判断机制；<br>（2）如果变量声明和赋值同时进行，<code>TS</code>编译器会自动判断变量的类型，可以省略掉类型声明</p><h2 id="类型种类"><a href="#类型种类" class="headerlink" title="类型种类"></a>类型种类</h2><p>类型      |例子  |    描述<br>|–|–|–|<br>number      |1, -33, 2.5 |    任意数字<br>string      |’hi’, “hi”, hi |    任意字符串<br>boolean  |    true、false    | 布尔值<br>字面量      |其本身|    限制变量的值就是该字面量的值<br>any  |    *    |任意类型<br>unknown      |<em>|    类型安全的any<br>void      | 空值（undefined）    | 没有值（或undefined）<br>never   |    没有值 |    不能是任何值<br>object  |    {name:’孙悟空’}    | 任意的JS对象<br>array  |    [1,2,3]    | 任意JS数组<br>tuple  |     [4,5]     | TS 新增元组类型，*</em>固定**长度数组<br>enum  |    enum{A, B}    | 枚举，TS 中新增类型</p><p>【案例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1、number</span></span><br><span class="line"><span class="keyword">let</span> decimal: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binary: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octal: number = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、string</span></span><br><span class="line"><span class="keyword">let</span> color: string = <span class="string">"blue"</span>;</span><br><span class="line">color = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、string </span></span><br><span class="line"><span class="keyword">let</span> fullName: string = <span class="string">`Bob Bobbington`</span>;</span><br><span class="line"><span class="keyword">let</span> age: number = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: string = <span class="string">`Hello, my name is <span class="subst">$&#123;fullName&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、字面量</span></span><br><span class="line"><span class="comment">// 可以使用 或语法 包含的所有字符</span></span><br><span class="line"><span class="keyword">let</span> color: <span class="string">'red'</span> | <span class="string">'blue'</span> | <span class="string">'black'</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、any</span></span><br><span class="line"><span class="keyword">let</span> d: any = <span class="number">4</span>;</span><br><span class="line">d = <span class="string">'hello'</span>;</span><br><span class="line">d = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 7、unknown</span></span><br><span class="line"><span class="keyword">let</span> notSure: unknown = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8、void</span></span><br><span class="line"><span class="comment">// 定义函数时，表示没有返回值，可以为 unknown 、null</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9、never</span></span><br><span class="line"><span class="comment">// 定义函数时，表示不返回，甚至不可以为 unknown 、null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10、对象 object（没啥用） </span></span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;;</span><br><span class="line"><span class="comment">// &#123;&#125; 用来指定对象中可以包含哪些类型</span></span><br><span class="line"><span class="keyword">let</span> b:&#123;<span class="attr">name</span>:string,age?:number&#125;</span><br><span class="line">b=&#123;<span class="attr">name</span>:<span class="string">'猪八戒'</span>&#125;</span><br><span class="line"><span class="comment">// [proName:String]: any 表示任意类型属性</span></span><br><span class="line"><span class="keyword">let</span> c:&#123;<span class="attr">name</span>:string,age?:number,[somename:string]:any&#125;</span><br><span class="line">c=&#123;<span class="attr">name</span>:<span class="string">'猪八戒'</span>,<span class="attr">age</span>: <span class="number">23</span>,<span class="attr">gander</span>: <span class="string">'man'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11、array 对象类型</span></span><br><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12、tuple 元组</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line">x = [<span class="string">"hello"</span>, <span class="number">10</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 13、enum 枚举</span></span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green = <span class="number">2</span>,</span><br><span class="line">  Blue = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有些情况下，变量的类型对于我们来说是很明确，但是<code>TS</code>编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><p>（1）<code>as</code> 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>（2）<code>&lt;&gt;</code> 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length;</span></span><br></pre></td></tr></table></figure><h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><h2 id="编译指定文件"><a href="#编译指定文件" class="headerlink" title="编译指定文件"></a>编译指定文件</h2><p>编译文件时，使用 <code>-w</code> 指令后，<code>TS</code>编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p><p>1、编译</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>2、编译</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译 xxx.ts 为 xxx.js文件 ,并监听该文件</span></span><br><span class="line">  tsc xxx.ts -w</span><br></pre></td></tr></table></figure><h2 id="编译整个项目（自动）"><a href="#编译整个项目（自动）" class="headerlink" title="编译整个项目（自动）"></a>编译整个项目（自动）</h2><p>如果终端直接 使用<code>tsc</code>指令，则可以自动将当前项目下的所有<code>ts</code>文件编译为<code>js</code>文件。<br>但是能直接使用<code>tsc</code>命令的前提是：要先在项目根目录下创建一个<code>ts</code>的配置文件 <code>tsconfig.json</code></p><p><code>tsconfig.json</code>的配置示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有`src`目录和`tests`目录下的文件都会被编译</span></span><br><span class="line">"include":["src/**/*", "tests/**/*"]</span><br><span class="line">"exclude": ["./src/hello/**/*"]</span><br><span class="line">"extends": "./configs/base"</span><br><span class="line">"files": [</span><br><span class="line">    "core.ts",</span><br><span class="line">    <span class="string">"sys.ts"</span></span><br><span class="line">  ],</span><br><span class="line">"compilerOptions": &#123;</span><br><span class="line">    "target": "ES6"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul><li>定义希望被编译文件所在的目录</li><li>默认值：[“<em>*/</em>“]</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"include":["src/**/*", "tests/**/*"]</span><br></pre></td></tr></table></figure><p>上述示例中，所有<code>src</code>目录和<code>tests</code>目录下的文件都会被编译</p><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><ul><li>定义不被编译排除的目录</li><li>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"exclude": ["./src/hello/**/*"]</span><br></pre></td></tr></table></figure><p>上述示例中，<code>src</code>下<code>hello</code>目录下的文件都不会被编译</p><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><ul><li>指定被编译文件的列表，只有需要编译的文件少时才会用到</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"files": [</span><br><span class="line">    "core.ts",</span><br><span class="line">    "sys.ts",</span><br><span class="line">    "types.ts",</span><br><span class="line">    "scanner.ts",</span><br><span class="line">    "parser.ts",</span><br><span class="line">    "utilities.ts",</span><br><span class="line">    "binder.ts",</span><br><span class="line">    "checker.ts",</span><br><span class="line">    <span class="string">"tsc.ts"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>上述列表中的文件都会被<code>TS</code>编译器所编译</p><h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h3><ul><li><p>编译选项是配置文件中重要、复杂的配置选项</p></li><li><p>在<code>compilerOptions</code>中包含多个子选项，完成对编译的配置</p><p>项目选项：<code>target</code>、<code>lib</code>、<code>module</code>、<code>outDir</code>、<code>outFile</code>、<code>allowJs</code>、<code>checkJs</code>、<code>removeComments</code>、<code>noEmit</code>、<code>sourceMap</code>、……</p><p><strong>target</strong></p><ul><li>设置<code>ts</code>代码编译的目标版本</li><li>可选值：<br>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li><li>示例：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"ES6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lib</strong>（一般设置，用默认配置）</p><ul><li>指定代码运行时所包含的库（宿主环境）</li><li>可选值：<br>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……</li><li>示例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"ES6"</span>,</span><br><span class="line">    <span class="string">"lib"</span>: [<span class="string">"ES6"</span>, <span class="string">"DOM"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>module</strong></p><ul><li>设置编译后代码使用的模块化系统</li><li>可选值：<br>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li><li>示例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"ES6"</span>,</span><br><span class="line">    <span class="string">"lib"</span>: [<span class="string">"ES6"</span>, <span class="string">"DOM"</span>],</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"CommonJS"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>outDir</strong></p><ul><li>编译后文件的所在目录</li><li>默认情况下，编译后的<code>js</code>文件会和<code>ts</code>文件位于相同的目录，设置<code>outDir</code>后可以改变编译后文件的位置</li><li>示例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line"> <span class="string">"target"</span>: <span class="string">"ES6"</span>,</span><br><span class="line">    <span class="string">"lib"</span>: [<span class="string">"ES6"</span>, <span class="string">"DOM"</span>],</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"CommonJS"</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"dist"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置后编译后的<code>js</code>文件将会生成到<code>dist</code>目录</p><p><strong>outFile</strong></p><ul><li>将所有的文件编译为一个<code>js</code>文件</li><li>默认会将所有的编写在全局作用域中的代码合并为一个<code>js</code>文件，如果<code>module</code>制定了<code>None</code>、<code>System</code>或<code>AMD</code>则会将模块一起合并到文件之中</li><li>示例：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"compilerOptions": &#123;</span><br><span class="line">"target": "ES6",</span><br><span class="line">    "lib": ["ES6", "DOM"],</span><br><span class="line">    "module": "CommonJS"</span><br><span class="line">    "outDir": "dist"</span><br><span class="line">    "outFile": "dist/app.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>allowJs</strong></p><ul><li>是否对<code>js</code>文件编译</li></ul><p><strong>checkJs</strong></p><ul><li>是否对<code>js</code>文件进行检查</li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><em>removeComments*</em></li><li>是否删除注释</li><li>默认值：<code>false</code></li></ul><p><strong>严格检查</strong>：<code>alwaysStrict</code>、<code>strict</code></p><p><strong>noEmit</strong></p><ul><li>不对代码进行编译</li><li>默认值：<code>false</code></li></ul><p><strong>noEmitOnError</strong></p><ul><li>有错误的情况下不进行编译</li><li>默认值：<code>false</code><h1 id="TypeScript-打包（webpack）"><a href="#TypeScript-打包（webpack）" class="headerlink" title="TypeScript 打包（webpack）"></a>TypeScript 打包（webpack）</h1><h2 id="webpack-打包"><a href="#webpack-打包" class="headerlink" title="webpack 打包"></a>webpack 打包</h2>1、构建工具</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</span><br></pre></td></tr></table></figure><p>共安装了7个包:</p><p>webpack：构建工具 webpack<br>webpack-cli：webpack 的命令行工具<br>webpack-dev-server：webpack 的开发服务器<br>typescript：ts 编译器<br>ts-loader：ts 加载器，用于在 webpack 中编译 ts 文件<br>html-webpack-plugin：webpack 中 html 插件，用来自动创建 html 文件<br>clean-webpack-plugin：webpack 中的清除插件，每次构建都会先清除目录</p><p>2、配置 webpack<br>根目录下创建 <code>webpack</code>的配置文件<code>webpack.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   optimization:&#123;</span><br><span class="line">       minimize: <span class="literal">false</span> <span class="comment">// 关闭代码压缩，可选</span></span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   entry: <span class="string">"./src/index.ts"</span>,</span><br><span class="line"></span><br><span class="line">   devtool: <span class="string">"inline-source-map"</span>,</span><br><span class="line"></span><br><span class="line">   devServer: &#123;</span><br><span class="line">       contentBase: <span class="string">'./dist'</span></span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   output: &#123;</span><br><span class="line">       path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">       filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">       environment: &#123;</span><br><span class="line">           arrowFunction: <span class="literal">false</span> <span class="comment">// 关闭webpack的箭头函数，可选</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   resolve: &#123;</span><br><span class="line">       extensions: [<span class="string">".ts"</span>, <span class="string">".js"</span>]</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="built_in">module</span>: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">               use: &#123;</span><br><span class="line">                   loader: <span class="string">"ts-loader"</span>     </span><br><span class="line">               &#125;,</span><br><span class="line">               exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   plugins: [</span><br><span class="line">       <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">       <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">           title:<span class="string">'TS测试'</span></span><br><span class="line">       &#125;),</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、配置 TS 编译选项<br>根目录下创建<code>tsconfig.json</code>，配置可以根据自己需要</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">       <span class="string">"target"</span>: <span class="string">"ES2015"</span>,</span><br><span class="line">       <span class="string">"module"</span>: <span class="string">"ES2015"</span>,</span><br><span class="line">       <span class="string">"strict"</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改 package.json 配置<br>修改 <code>package.json</code> 添加如下配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="comment">// webpack 打包 </span></span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="comment">// webpack 服务器启动 并在谷歌启动 实时打包并更新页面</span></span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack serve --open chrome.exe"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Babel-适配"><a href="#Babel-适配" class="headerlink" title="Babel 适配"></a>Babel 适配</h2><p>除了<code>webpack</code>，开发中还经常需要结合<code>babel</code>来对代码进行转换，以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将<code>babel</code>引入到项目中；</p><blockquote><p>TS 编译成 JS 代码，只支持部分代码简单的转换，<br>对于例如：Promise 等 ES6 特性，TS 无法直接转换，这时还要用到 babel 来做转换；</p></blockquote><p>安装依赖包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/core @babel/preset-env babel-loader core-js</span><br></pre></td></tr></table></figure><p>共安装了4个包，分别是：</p><p>@babel/core：babel 的核心工具</p><p>@babel/preset-env：babel 的预定义环境</p><p>@babel-loader：babel 在webpack 中的加载器</p><p>core-js：core-js 用来使老版本的浏览器支持新版 ES 语法</p><p>修改<code>webpack.config.js</code>配置文件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        presets: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="string">"targets"</span>:&#123;</span><br><span class="line">                                    <span class="comment">// 指定要兼容的浏览器版本；</span></span><br><span class="line">                                        <span class="string">"chrome"</span>: <span class="string">"58"</span>,</span><br><span class="line">                                        <span class="string">"ie"</span>: <span class="string">"11"</span></span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    <span class="string">"corejs"</span>:<span class="string">"3"</span>,</span><br><span class="line">                                    <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">"ts-loader"</span>,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解决浏览器兼容问题，在配置选项的<code>targets</code>中指定要兼容的浏览器版本；</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>通过将复杂的事情，描述成对象的行为，通过数据和行为构成对象。</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    属性名: 类型;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(参数: 类型)&#123;</span><br><span class="line">        <span class="keyword">this</span>.属性名 = 参数;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    方法名()&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中，<code>this</code>表示当前实例对象<br>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: string, age: number)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`大家好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new关键字 调用构造函数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'孙悟空'</span>, <span class="number">18</span>);</span><br><span class="line">p.sayHello();</span><br></pre></td></tr></table></figure><p>简写<br>使用<code>constructor</code>定义一个构造器方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(public name: string, public age: number) &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">sayHello()&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`大家好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>1、静态属性（static）：</p><ul><li>声明为<code>static</code>的属性或方法不再属于实例，而是属于类；</li></ul><p>2、只读属性（readonly）：</p><ul><li>如果在声明属性时添加一个    <code>readonly</code>，则属性便成了只读属性无法修改</li></ul><p>3、<code>TS</code>中属性具有三种修饰符：</p><ul><li>public（默认值），可以在类、子类和对象中修改</li><li>protected ，可以在当前类、当前子类中修改</li><li>private ，可以在当前类中修改</li></ul><p>4、示例<br>public</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'孙悟空'</span>, <span class="number">18</span>,<span class="string">'男'</span>);</span><br><span class="line">p.name = <span class="string">'猪八戒'</span>;<span class="comment">// 可以通过对象修改</span></span><br></pre></td></tr></table></figure><p>protected</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'孙悟空'</span>, <span class="number">18</span>);</span><br><span class="line">p.name = <span class="string">'猪八戒'</span>;<span class="comment">// 不能修改</span></span><br></pre></td></tr></table></figure><p>private </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    setName()&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//子类中不能修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'孙悟空'</span>, <span class="number">18</span>);</span><br><span class="line">p.name = <span class="string">'猪八戒'</span>;<span class="comment">// 不能修改</span></span><br></pre></td></tr></table></figure><h2 id="属性存取器"><a href="#属性存取器" class="headerlink" title="属性存取器"></a>属性存取器</h2><p>由于可能会出现用户填写数字不合法的情况，例如：年纪为负数。<br>因此，某些情况下不允许用户直接修改属性值，而是通过封装方法改变属性值（在方法内部实现判断）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    private _age: number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(age: number)&#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> age()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> age(value: string)&#123;</span><br><span class="line">    <span class="keyword">if</span>(value &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">this</span>._age= value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="number">15</span>);</span><br><span class="line"><span class="comment">// 实际通过调用getter方法读取age属性</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age);</span><br><span class="line"><span class="comment">// 实际通过调用setter方法修改age属性 </span></span><br><span class="line">p1.name = <span class="number">89</span>;</span><br></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p><p>静态属性（方法）使用<code>static</code>开头<br>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tools</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> sum(num1: number, <span class="attr">num2</span>: number)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Tools.PI);</span><br><span class="line"><span class="built_in">console</span>.log(Tools.sum(<span class="number">123</span>, <span class="number">456</span>));</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>为了减少代码重复率，提高开发效率，使用继承父类，子类便可以使用父类的属性和方法</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: string, age: number)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    bark()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在汪汪叫！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'旺财'</span>, <span class="number">4</span>);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure><p>上述代码实现了继承，还可以在不修改类的情况下完成对类的扩展</p><p>当子类需要对父类的属性做补充时，需要在子类写构造函数完成属性值设置，并在构造函数中调用父类<code>super(参数)</code>。</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>发生继承时，子类中方法会替换掉父类中的同名方法，这就称为方法的重写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: string, age: number)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`父类中的run方法！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    bark()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在汪汪叫！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`子类中的run方法，会重写父类中的run方法！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'旺财'</span>, <span class="number">4</span>);</span><br><span class="line">dog.run();<span class="comment">// 子类中的run方法，会重写父类中的run方法！</span></span><br></pre></td></tr></table></figure><p>在子类中可以使用<code>super</code>来完成对父类的引用</p><h2 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h2><p>使用<code>abstract</code>关键字开头，表示抽象类、抽象方法。</p><ul><li>抽象类可以包含声明抽象方法、普通方法；</li><li>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例；</li><li>抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  abstract run(): <span class="keyword">void</span>;</span><br><span class="line">  bark()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'动物在叫~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'狗在跑~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口主要负责定义一个类的结构，接口可以去限制一个对象。<br>使用<code>Interface</code>关键字开头，接口的作用类似于抽象类。<br>不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">   name: string;</span><br><span class="line">   sayHello():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">// 区别于继承：extends </span></span><br><span class="line">   <span class="keyword">constructor</span>(public name: string) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sayHello() &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'大家好，我是'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>泛型是<strong>任意类型</strong>，可以说是类型变量，根据传递的值的类型自动识别泛型所表示的<strong>类型</strong></p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>当定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时需要使用泛型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>参数</strong>和<strong>返回值</strong>类型不确定，使用<code>any</code>，但是很明显这样做是不合适的：首先使用<code>any</code>会关闭<code>TS</code>的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型。</p><p>泛型的使用：定义+使用，其中括号<code>&lt;&gt;</code>表示<strong>定义</strong>泛型，使用泛型前必须定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code>的类型值是参数<code>arg</code>的类型，例如，参数<code>arg = 10</code>，则<code>T === number</code>。</p><p>泛型函数调用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="number">10</span>) <span class="comment">// TS 自动推断T的值</span></span><br><span class="line">test&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>) <span class="comment">// 手动指定泛型</span></span><br></pre></td></tr></table></figure><p>多个泛型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">a: T, b: K</span>): <span class="title">K</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;number, string&gt;(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  prop: T;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(prop: T)&#123;</span><br><span class="line">      <span class="keyword">this</span>.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myc = <span class="keyword">new</span> MyClass(<span class="string">'嘻嘻嘻'</span>) <span class="comment">// TS 自动判断 T 是 String 类型</span></span><br><span class="line"><span class="keyword">const</span> myc = <span class="keyword">new</span> MyClass&lt;string&gt;(<span class="string">'嘻嘻嘻'</span>) <span class="comment">//直接指定 T是 String</span></span><br></pre></td></tr></table></figure><p>继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface MyInter&#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">MyInter</span>&gt;(<span class="params">arg: T</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'123'</span>) <span class="comment">// 字符串'123'有length 属性</span></span><br><span class="line">test(&#123;<span class="attr">length</span>:<span class="number">10</span>&#125;) <span class="comment">// 对象有length 属性，值为 10</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 node 的身份认证</title>
      <link href="/2022/09/11/node%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
      <url>/2022/09/11/node%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h1><h2 id="不同开发模式下的身份认证"><a href="#不同开发模式下的身份认证" class="headerlink" title="不同开发模式下的身份认证"></a>不同开发模式下的身份认证</h2><p>对于服务端渲染和的后端分离这两种开发模式来说，分别有看不同的身份认证方案：</p><p>① 服务端渲染推荐使用<code>Session</code>认证机制</p><p>② 前后端分离推荐使用 <code>JWT</code>认证机制</p><h2 id="Session-认证机制"><a href="#Session-认证机制" class="headerlink" title="Session 认证机制"></a>Session 认证机制</h2><h3 id="HTTP-无状态性"><a href="#HTTP-无状态性" class="headerlink" title="HTTP 无状态性"></a>HTTP 无状态性</h3><p>了解<code>HTTP</code>协议的无状态性是进一步学习 <code>Session</code>认证机制的必要前提。</p><p><code>HTTP</code>协议的无状态性，指的是客户端的每次<code>HTTP</code>请求都是独立的，连续多个请求之间没有直接的关系，<strong>服务器不会主动保留每次<code>HTTP</code>请求的状态</strong>。</p><p>注意：现实生活中的会员卡身份认证方式，在<code>Web</code>开发中的专业术语叫做<code>Cookie</code>。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><code>Cookie</code>是存储在用户浏览器中的一段不超过<code>4 KB</code>的字符串。它由一个名称(Name)、一个值(Value) 和其它几个用于控制<font color='#8A2BE2'>Cookie有效期</font>、<font color='#8A2BE2'>安全性</font>、<font color='#8A2BE2'>使用范围</font>的可选属性组成。</p><p>不同域名下的<code>Cookie</code>各自独立，每当客户端发起请求时，会<strong>自动</strong>把<strong>当前域名</strong>下<strong>所有</strong>未过期的<code>Cookie</code>一同发送到服务器。</p><p><code>Cookie</code>的几大特性：</p><p>①自动发送</p><p>②域名独立</p><p>③过期时限</p><p>④<code>4KB</code>限制</p><h3 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h3><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie,客户端会自动将<code>Cookie</code>保存在浏览器中。<br>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的<code>Cookie</code>，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。</p><h3 id="Cookie-不具有安全性"><a href="#Cookie-不具有安全性" class="headerlink" title="Cookie 不具有安全性"></a>Cookie 不具有安全性</h3><p>由于<code>Cookie</code>是存储在浏览器中的，而且浏览器也提供了读写<code>Cookie</code>的<code>API</code>，因此<code>Cookie</code>很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过<code>Cookie</code>的形式发送给浏览器。</p><h3 id="提高身份认证的安全性"><a href="#提高身份认证的安全性" class="headerlink" title="提高身份认证的安全性"></a>提高身份认证的安全性</h3><p>为了防止客户端伪造<code>Cookie</code>，服务器端在拿到客户端出示的<code>Cookie</code>之后，需要对其进行身份认证。只有服务端确认存在的<code>Cookie</code>，才能被正常使用。</p><p>其中，<code>Cookie</code> + 身份认证 =<code>session</code>认证机制。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 身份认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理和分析基础</title>
      <link href="/2022/09/10/Python/"/>
      <url>/2022/09/10/Python/</url>
      
        <content type="html"><![CDATA[<h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><p>指定路径、加速下载：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install  -i https://pypi.doubanio.com/simple/  --trusted-host pypi.doubanio.com    --target=d:\python\python37\lib\site-packages     &lt;包名&gt;</span><br></pre></td></tr></table></figure><p>查看<code>jupyter</code> 执行环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.executable)</span><br></pre></td></tr></table></figure><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h2><p>数据类型：DataFrame</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.corr()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识 node</title>
      <link href="/2022/09/05/node%E5%85%A5%E9%97%A8/"/>
      <url>/2022/09/05/node%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><center>Node.js</h1><h1 id="光速入门"><a href="#光速入门" class="headerlink" title="光速入门"></a>光速入门</h1><h2 id="node-js-概述"><a href="#node-js-概述" class="headerlink" title="node.js 概述"></a>node.js 概述</h2><p>内容部分存在将<code>node.js</code>简写为<code>node</code></p><p>1、node 是什么 ?</p><blockquote><p><code>node</code>不是一门语言，而是<code>JavaScript</code>的运行环境，和浏览器一样可以执行<code>JavaScript</code>代码。</p></blockquote><p>2、为什么<strong>浏览器</strong>和<code>Node</code>可以执行<code>JavaScript</code>？</p><blockquote><p>都是因为了内置<code>JavaScript V8</code>引擎，通过将<code>JavaScript</code>编译成为计算机能识别的机器码</p></blockquote><p>3、浏览器和<code>Node</code>执行<code>JavaScript</code>代码时存在区别嘛？</p><blockquote><p>有！在内置<code>JavaScript V8</code>引擎，只能执行一些基本操作，比如声明变量、函数，执行流程控制语句，像<code>if</code>判断和<code>for</code>循环语句等。</p><ul><li><p><strong>浏览器</strong>为了让<code>JavaScript</code>去操作窗口以及运行在浏览器中的<code>html</code>文档，浏览器会向<code>JavaScript v8 engine</code>添加一些<code>API</code>（就是<code>DOM</code> 和<code>BOM</code>）控制它们，所以<code>JavaScript</code>在浏览器窗口运行时，可以控制<strong>浏览器窗口对象</strong>和<strong>DOM 文档对象</strong>。</p></li><li><p><code>node</code>是没有<strong>DOM 对象</strong>和<strong>BOM 对象</strong>的。所以node不能执行与他们相关的代码，比如：<code>window.alert()</code>或者<code>document.getElementById().</code>都是浏览器特有的，而<strong>node</strong>中，作者向<code>Node</code>中添加了很多系统级别的<code>API</code></p></li></ul></blockquote><p><code>JavaScript</code>运行在浏览器中控制的是<strong>浏览器窗口</strong>和<strong>DOM</strong>文档。（ ECMAscript + DOM + BOM ）<br><code>JavaScript</code>运行在<code>Node.js</code>中控制的操作系统级别的内容。（ ECMAscript + Node API ）</p><p>4、为什么浏览器中的<code>JavaScript</code> 不能控制系统级别的<code>API</code> ?</p><blockquote><p>浏览器是运行在用户的操作系统中的，如果能控制系统级别的<code>API</code>就会存在安全问题。<br><code>Node.js</code>是运行在远程的服务器中的，访问的是服务器系统<code>API</code>，不存在这方面的安全问题。</p></blockquote><p>5、Node.js 能够做什么 ?</p><blockquote><p>我们通常使用它来：构建服务器端应用、创建前端工程化工具。<br><code>JavaScript</code>运行在浏览器中——客户端<code>JavaScript</code>。<br><code>JavaScript</code>运行在<code>Node.js</code>中——服务器端<code>JavaScript</code>。</p></blockquote><h2 id="Node-安装"><a href="#Node-安装" class="headerlink" title="Node 安装"></a>Node 安装</h2><blockquote><p>查看 Node 版本： node -v<br>查看 Npm 版本：npm -v</p></blockquote><h2 id="解决安装问题"><a href="#解决安装问题" class="headerlink" title="解决安装问题"></a>解决安装问题</h2><blockquote><p>配置环境变量<code>path</code>（path 是给系统指路的）；</p><p>配置后，即可全局使用<code>node</code>命令。</p></blockquote><h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>) <span class="comment">// window is not defined</span></span><br></pre></td></tr></table></figure><p>在<code>Node.js</code>环境中是没有<code>window</code>的，所以<code>window</code>对象自然是未定义的。<br>在<code>Node.js</code>环境中全局对象为<code>global</code>，在<code>global</code>对象中会存在一些和 <code>window</code>对象中名字且功能相同的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">global.console.log</span><br><span class="line">global.setInterval</span><br><span class="line">global.clearInterval</span><br><span class="line">global.setTimeout</span><br><span class="line">global.clear Timeout</span><br><span class="line">global.setlmmediate</span><br></pre></td></tr></table></figure><p>在浏览器声明的变量会挂载到<strong>全局对象</strong>上；在<code>Node.js</code>环境中声明的变量不会被添加到<strong>全局对象</strong>中，变量声明后只能在当前文件中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(global.message) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><h3 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h3><p>在<code>Node.js</code>环境中，默认就支持模块系统，该模块系统遵循<code>CommonJS</code>规范。<br>一个<code>JavaScript</code>文件就是一个模块， 在模块文件中定义的<strong>变量</strong>和<strong>函数</strong>默认只能在模块文件内部使用，如果需要在其他文件中使用，必须显式声明将其进行<strong>导出</strong>。</p><h3 id="模块成员导出"><a href="#模块成员导出" class="headerlink" title="模块成员导出"></a>模块成员导出</h3><p>在每一个模块文件中，都会存在一个<code>module</code>对象，即模块对象。</p><p>在模块对象中保存了和当前模块相关信息。<br>在模块对象中有一个属性<code>exports</code>,它的值是一个对象，模块内部需要被导出的成员都应该存储在到这个对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">exports: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.endPoint = str</span><br><span class="line"><span class="built_in">module</span>.exports.log = log</span><br></pre></td></tr></table></figure><h3 id="模块成员导入"><a href="#模块成员导入" class="headerlink" title="模块成员导入"></a>模块成员导入</h3><p>在其他文件中通过<code>require</code>方法引入模块，<code>require</code> 方法的返回值就是对应模块的<code>module.exports</code>对象。<br>在导入模块时，模块文件后缀<code>.js</code> 可以省略，文件路径不可省略。</p><p>1、<code>require</code>方法属于<strong>同步</strong>导入模块，模块导入后可以立即使用。</p><p>2、通过<code>require</code>方法引入模块时，会<strong>立即执行</strong>该模块中的代码。</p><p>3、在导入其他模块时，建议使用<code>const</code>关键字声明常量，防止模块被重置。</p><p>导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.log = log</span><br></pre></td></tr></table></figure><p>导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">"./some"</span>)</span><br><span class="line">logger = <span class="number">1</span> </span><br><span class="line">logger.log() <span class="comment">// log not a function</span></span><br></pre></td></tr></table></figure><p>4、只导出一个成员方便其他模块使用时，可以采用以下导入方式。</p><p>导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//some.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">"./some"</span>)</span><br><span class="line">logger(<span class="string">"hello"</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="模块包装函数"><a href="#模块包装函数" class="headerlink" title="模块包装函数"></a>模块包装函数</h3><p>Module Wapper Function</p><p>1、<code>Node.js</code>是如何实现模块的，为什么在模块文件内部定义的变量在模块文件外部访问不到 ?<br>2、每一个模块文件中都会有<code>module</code>对象和<code>require</code>方法，它们是从哪来的 ?</p><blockquote><p>在模块文件执行之前，模块文件中的代码会被包裹在模块包装函数当中，这样每个模块文件中的代码就都拥有了自己的作用域，所以在模块外部就不能访问模块内部的成员了。</p></blockquote><p>模块包装函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports, require, module,__filename,__dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参数：</p><p>exports：导出对象，它使用的是<code>module.export</code>的引用地址（同：module.exports）</p><p>require：导入对象 </p><p>__filename：当前文件的路径</p><p>__dirname：当前文件所在的根目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(__filename)</span><br><span class="line"><span class="comment">// /Users/ administrators/Desktop/Node/ code/logger.js</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname)</span><br><span class="line"><span class="comment">// /Users/ administ rators/Desktop/Node/ code</span></span><br></pre></td></tr></table></figure><p>其实，在导入模块时最终导入的是<code>module.exports</code>对象，所以在使用<code>exports</code>对象<strong>添加导出成员</strong>时不能修改引用地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = log <span class="comment">//这是错误的写法.</span></span><br></pre></td></tr></table></figure><p>以上代码会导致，<code>module.exports</code> 导出的内容为空</p><h3 id="Node-js-内置模块"><a href="#Node-js-内置模块" class="headerlink" title="Node.js 内置模块"></a>Node.js 内置模块</h3><p>在<code>Node.js</code>安装完成后，我们可以使用自己开发的模块，也可以使用<code>node</code>的内置模块。</p><p><code>在引入内置模块时，直接使用模块的名字，前面不需要加任何路径。</code></p><h4 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h4><p><code>Path</code>：模块内提供了一些和路径操作相关的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(path.parse( filename))</span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">    root: ', </span></span><br><span class="line"><span class="comment">    dir: /Users/administrators/Desktop/node_ test',</span></span><br><span class="line"><span class="comment">    base: 'app.js';</span></span><br><span class="line"><span class="comment">    ext: 'js',</span></span><br><span class="line"><span class="comment">    name: 'app'</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h4 id="File-system-模块"><a href="#File-system-模块" class="headerlink" title="File system 模块"></a>File system 模块</h4><p><code>File system</code>：文件操作系统，提供了和操作文件相关的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取当前文件处于的根目录</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="comment">// 同步方法 </span></span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(<span class="string">"./"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(files) <span class="comment">// [ 'app.js', 'logger.js' ]</span></span><br><span class="line"><span class="comment">// 异步方法 </span></span><br><span class="line">fs.readdir(<span class="string">" ./"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, files</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error) <span class="comment">// null I Error t</span></span><br><span class="line">    <span class="built_in">console</span> log(files) <span class="comment">// [ 'appjs', 'logger.js' ]I undefined </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="Node-js-软件包"><a href="#Node-js-软件包" class="headerlink" title="Node.js 软件包"></a>Node.js 软件包</h3><p>每一个基于<code>Node.js</code>平台开发的应用程序都是<code>Node.js</code>软件包。</p><p>所有<code>Node.js</code>软件包都被托管在<a href="http://www.npmjs.com" target="_blank" rel="noopener">www.npmjs.com</a> 中。而且可以自己开发包，上传供别人使用。</p><h3 id="什么是-NPM"><a href="#什么是-NPM" class="headerlink" title="什么是 NPM"></a>什么是 NPM</h3><p><code>Node Package Manager</code>, <code>Node,js</code> 环境中的软件包管理器。随<code>Node.js</code>一起捆绑安装。</p><p>它可以将<code>Node</code>软件包，添加到我们的应用程序中并对其进行管理，比如<strong>下载</strong>、<strong>删除</strong>、<strong>更新</strong>、<strong>查看版本</strong>等等。</p><p>它<strong>没有用户界面</strong>，需要在命令行工具中通过命令的方式使用，对应的命令就是<code>npm</code>。</p><p><code>NPM</code>和<code>Node</code>是两个独立的应用程序，只是被捆绑安装了，可以通过版本号证明。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><code>Node.js</code>规定在每一个软件包中 都必须包含一个叫做 <code>package.json</code>的文件。</p><p>它是应用程序的描述文件，包含和应用程序相关的信息，比如应用名称，应用版本，应用作者等等。</p><p>通过<code>package.json</code>文件可以方便管理应用和发布应用。</p><p>创建<code>package.json</code>文件: <code>npm init</code></p><p>快速创建<code>package.json</code>文件: <code>npm init --yes</code></p><h3 id="下载node软件包"><a href="#下载node软件包" class="headerlink" title="下载node软件包"></a>下载<code>node</code>软件包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;包名&gt;</span><br></pre></td></tr></table></figure><p>软件包下载完成后会发生三件事:</p><p>1、软件包会被存储在<code>node_modules</code>文件夹中，如果在应用中不存在此文件夹，<code>npm</code>会自动创建。</p><p>2、软件包会被记录在<code>package.json</code> 文件中包含软件包的名字以及版本号。</p><p>3、<code>npm</code>会在应用中创建<code>package-lock.json</code> 文件，用于记录软件包及软件包的依赖包的下载地址及版本。</p><h3 id="使用-Node-js-软件包"><a href="#使用-Node-js-软件包" class="headerlink" title="使用 Node.js 软件包"></a>使用 Node.js 软件包</h3><p>在引入第三方软件包时，在<code>require</code>方法中不需要加入路径信息，只需要使用软件包的名字即可，require 方法会</p><p>自动去<code>node_ modules</code>文件夹中进行查找。（不是内置模块才会去<code>node_ modules</code>中查找）</p><h3 id="软件包依赖问题说明"><a href="#软件包依赖问题说明" class="headerlink" title="软件包依赖问题说明"></a>软件包依赖问题说明</h3><p>1、比如，我下载了<code>mongoose</code>软件包，但是在<code>node_ modules</code> 文件夹中突然多出了很多其他我没下载的软件包，为什么 ?</p><blockquote><p>实际上它们又是<code>mongoose</code>依赖的软件包。</p></blockquote><p>2、为什么mongoose依赖的软件包不放在mongoose文件夹中呢?</p><blockquote><p>在早期的<code>npm</code>版本中，某个软件包依赖的其他软件包都会被放置在该软件包<strong>内部</strong>的<code>node_ modules</code>文件夹中，但是这样做存在<br>两个问题：</p><p>① 【重复下载】：很多软件包都会有相同的依赖，导致开发者在一个项目中会下载很多重复的软件包，比如<code>A</code>依赖<code>X</code>,<br><code>B</code>依赖<code>X</code>, <code>C</code>依赖<code>X</code>，这样<code>X</code>就会被<strong>重复下载</strong>三次。</p><p>② 【不易删除】：文件夹嵌套层次太深，导致文件夹在<code>windows</code>系统中不能被直接删除。比如，<code>A</code>依赖<code>B</code>,<code>B</code>依赖<code>C</code>，<code>C</code>依赖<code>D</code>，会发生依次嵌套的情况。</p></blockquote><p>3、所有的软件包都放置在 node_modules 文件夹中不会导致软件包的版本冲突吗?</p><blockquote><p>会出现，但是已解决：<br>比如<code>A</code>依赖<code>X</code>的<code>1</code>版本，<code>B</code>依赖<code>X</code>的<code>2</code>版本，如果你先下载的是<code>A</code>，那么<code>A</code>依赖的<code>X</code>会被放置在根目录的<code>node__modules</code>文件夹中，当下载<code>B</code>时，由于在根目录中已经存在<code>X</code>，但是版本不一致，那么<code>B</code>依赖的<code>X</code>就会被放置在<code>B</code>软件包中的<code>node_module</code> 文件夹中，通过此方式解决软件包版本冲突的问题。</p></blockquote><p>4、node_ modules 文件夹中的软件包都需要提交到 git 仓库中吗?</p><blockquote><p>实际上，应用程序依赖了哪些软件包在<code>package.json</code>文件中都会有记录，其他人可以通过<code>npm install</code>命令重新下载它们。为了<br>保持下载版本一直, <code>npm</code>还会根据<code>package-lock.json</code> 文件中的记录的地址进行下载。<br>将应用程序提交到版本库之前，将<code>node_ modules</code> 写到<code>.gitignore</code> 文件中。</p></blockquote><h3 id="项目依赖-VS-开发依赖"><a href="#项目依赖-VS-开发依赖" class="headerlink" title="项目依赖 VS 开发依赖"></a>项目依赖 VS 开发依赖</h3><p>下载<strong>开发</strong>依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D</span><br></pre></td></tr></table></figure><p>开发环境中下载依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>生产环境中下载依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --prod</span><br></pre></td></tr></table></figure><h3 id="本地安装-VS-全局安装"><a href="#本地安装-VS-全局安装" class="headerlink" title="本地安装 VS 全局安装"></a>本地安装 VS 全局安装</h3><p>1、<strong>本地</strong>安装 VS <strong>全局</strong>安装</p><p><strong>本地</strong>安装：将软件包下载到应用根目录下的<code>node_modules</code> 文件夹中，软件包只能在当前应用中使用。</p><p><strong>全局</strong>安装：将软件包下载到操作系统的指定目录中，可以在任何应用中使用。</p><blockquote><p>通过<code>-g</code> 选项将软件包安装到全局：npm install <pkg> -g<br>查看全局软件包安装位置：npm root -g<br>删除全局中的软件包： npm un <pkg> -g<br>查看全局中安装了哪些软件包：npm list -g –depth 0<br>查看全局中有哪些过期软件包： npm outdated -g</p></blockquote><p>2、npm-check-updates 强制更新</p><p><code>npm-check-updates</code> 可以查看应用中有<strong>哪些软件包过期</strong>了，可以强制更新<code>package.json</code>文件中软件包版本</p><p>将<code>npm-check-updates</code>安装到全局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm-check-updates -g</span><br></pre></td></tr></table></figure><p>查看过期软件包： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-check-updates</span><br></pre></td></tr></table></figure><p>更新 <code>package.json</code>记录的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure><h3 id="更改-npm-镜像地址"><a href="#更改-npm-镜像地址" class="headerlink" title="更改 npm 镜像地址"></a>更改 npm 镜像地址</h3><p>由于<code>npmjs.com</code>是国外的网站，大多数时候下载软件包的速度会比较慢，如何解决呢 ?</p><p>可以通过配置的方式更改<code>npm</code>工具的下载地址。</p><p>1、<strong>获取</strong><code>npm</code>配置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list -| --json</span><br></pre></td></tr></table></figure><p>-|：列表所有默认配置选项<br>–json：以<code>json</code>格式显示配置选项</p><p>2、<strong>设置</strong><code>npm</code>配置<br>获取<code>npm</code>下载地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>获取<code>npm</code>用户配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get userconfig</span><br></pre></td></tr></table></figure><p>3.更改npm镜像地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry  https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><p><code>npx</code>是<code>npm</code>软件包提供的命令，它是<code>Node.js</code>平台下软件包执行器。</p><p>主要用途有两个：</p><p>第一个是<strong>临时安装软件</strong>包执行后删除它，第二个是执行<strong>本地安装</strong>的提供命令的软件包。</p><p>1、临时安装软件包执行后删除软件包</p><p>有些提供命令的软件跑使用的频率并不高，占用存储空间，希望临时下载使用后，自动删掉它。</p><p>比如，<code>create-react-app</code>脚手架工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app react-test</span><br></pre></td></tr></table></figure><p>2、执行本地安装的软件包</p><p>本地和全局都安装了相同的包，该使用哪个版本的包？</p><p>该软件包可以在本地进行安装，在<code>A</code>项目中安装它的<code>1</code>版本,在<code>B</code>项目中安装它的2版本，在应用中可以通过<code>npx</code>调</p><p>用<code>node_ modules</code> 文件夹中安装的命令工具。</p><blockquote><p>将软件包安装到应用本地是现在最推荐的做法：</p><p>一是可以防止软件包的版本冲突问题，二是其他开发者在恢复应用依赖时可以恢复全部依赖。</p><p>因为软件包安装到本地后会被<code>package.json</code>文件记录，其他开发者在运行项目时不会因为缺少依赖而报错。</p></blockquote><h3 id="配置程序入口文件"><a href="#配置程序入口文件" class="headerlink" title="配置程序入口文件"></a>配置程序入口文件</h3><p>每个<code>node</code>软件包中都有一个<code>package.json</code>文件，可以通过该文件中的<code>main</code>属性值设置入口文件。</p><p>1、作用</p><p>应用程序入口文件就是应用程序执行的起点，就是启动应用程序时执行的文件。</p><blockquote><p>场景一：其他开发者拿到你的软件包以后，通过<code>package.json</code>该文件可以知道应用的入口文件是谁，通过入口文件启动应用。</p><p>场景二：通过<code>node</code>应用文件夹命令启动应用。<code>node</code> 命令会执行<code>package.json</code>文件中<code>main</code>选项指定的入口文件，如果没有指定入口文件，则执行<code>index.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json 中 的 main 属性</span></span><br><span class="line">main:<span class="string">'index.js'</span></span><br><span class="line"><span class="comment">// 在终端输入命令，实际执行的是 app 文件夹下的index.js文件</span></span><br><span class="line">node app</span><br></pre></td></tr></table></figure></blockquote><h3 id="模块查找规则（require）"><a href="#模块查找规则（require）" class="headerlink" title="模块查找规则（require）"></a>模块查找规则（require）</h3><p>添加文件后缀：查找指定文件，不添加文件后缀，按照以下模块查找规则查找：</p><p>首先检查是不是<strong>系统模块</strong>：</p><p>不是，按照规则 <code>1</code> 直接返回；</p><p>是，按照规则 <code>2</code> 到<code>node_ modules</code>文件夹查找，按照规则 <code>1</code> 执行查找。</p><p>1、<strong>指定</strong>文件查找路径（自己的 js 模块）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./server"</span>)</span><br></pre></td></tr></table></figure><p>查找顺序：</p><blockquote><p>1.查找 server.js 文件。<br>2.（1 没找到），查找 server.json 文件。<br>3.（1、2 没找到），查找 server <strong>文件夹</strong>，查看入口文件（package.json -&gt; main）。<br>4.（1、2、3 没找到），查找 server <strong>文件夹</strong>中的 index.js 文件。</p></blockquote><p>2、<strong>未指定</strong>查找路径（系统的 js 模块）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'server'</span>)</span><br></pre></td></tr></table></figure><p><code>modules</code>对象的<code>path</code>属性记录了<strong>模块路径</strong>查找数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paths: [</span><br><span class="line">    <span class="string">'/Users/administrators/Desktop/Node/code/node_ modules'</span>,</span><br><span class="line">    <span class="string">'/Users/administrators/Desktop/Node/node_ modules'</span>,</span><br><span class="line">    <span class="string">'/Users/administrators/Desktop/node_ modules'</span>,</span><br><span class="line">    <span class="string">'/Users/administrators/node_ modules'</span>,</span><br><span class="line">    <span class="string">'/Users/node_ modules'</span>,</span><br><span class="line">    <span class="string">'/node_ modules'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以上代码表示，在当前的文件根目录中的<code>node_ modules</code>中不能查找到模块，会一直往<strong>上一级</strong>的<code>node_ modules</code>中查找，直到根文件目录没查找到<code>node_ modules</code>，<strong>报错</strong>为止。</p><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="CPU与存储器"><a href="#CPU与存储器" class="headerlink" title="CPU与存储器"></a>CPU与存储器</h2><p>目标：了解程序运行过程中<code>CPU</code>和<strong>存储器</strong>起到了什么作用 / 扮演了什么角色</p><ol><li>CPU<br>中央处理器，计算机核心部件，负责运算和指令调用。<br>开发者编写的<code>JavaScript</code>代码在被编译为<strong>机器码</strong>以后就是通过<code>CPU</code>执行的。</li><li>存储器<br>内存：用于临时存储数据，断电后数据丢失。由于数据读写速度快，计算机中的应用都是在内存中运行的。<br>磁盘：用于持久存储数据，断电后数据不丢失。内部有磁头依靠马达转动在盘片上读写数据，速度比内存慢。<br>计算机应用程序在<strong>没有运行时</strong>是存储在<strong>磁盘</strong>中的，当我们<strong>启动应用程序</strong>后，应用程序会被加载到<strong>内存</strong>中运行，应用程序中的<strong>指令</strong>会被中央处理器<code>CPU</code>来执行。</li></ol><h2 id="什么是-I-O"><a href="#什么是-I-O" class="headerlink" title="什么是 I/O"></a>什么是 I/O</h2><p><code>I</code>就是 <code>Input</code>表示输入，<code>O</code>就是Output 表示输出，<code>I/O</code>操作就是输入/ 输出操作。什么样的操作属于<code>I/O</code>操作呢?</p><p>输入/ 输出是相对于<strong>内存</strong>来说的：</p><blockquote><p>比如：数据库的读写操作就是<code>I/O</code>操作，因为数据库文件是存储在<strong>磁盘中</strong>的，而我们编写的程序是运行在<strong>内存中</strong>的，将内存中的数据写入数据库对于内存来说就是输出，查询数据库中的数据就是将<strong>磁盘</strong>中的数据读取到<strong>内存</strong>中，对于内存来说就是输入。</p></blockquote><h3 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h3><p>无论<code>l/O</code>操作需要花费多少时间，在<code>I/O</code>操作执行完成后，<code>CPU</code>都是需要获取到操作结果的，那么， <code>CPU</code>在发出<code>I/O</code>操作指令后是否<br>要等待<code>I/O</code>操作执行完成呢 ?</p><p>这就涉及到<code>I/O</code>操作模型了，<code>I/O</code> 操作的模型有两种。</p><blockquote><p>第一种：CPU<strong>等待</strong> I/O 操作执行完成获取到操作结果后再去执行其他指令。这是同步 I/O 操作（<strong>阻塞 I/O</strong>）。<br>第二种：CPU<strong>不等待</strong> I/O 操作执行完成，CPU 在发出 I/O 指令后，内存和磁盘开始工作，CPU 继续执行其他指令。当 I/O 操作完成后再通知 CPU I/O 操作的结果。这是异步I/O操作（<strong>非阻塞 I/O</strong>）。</p></blockquote><p>同步 <code>I/O</code> ：在代码中的表现，就是代码<strong>暂停执行</strong>等待I/O操作，I/O 操作执行完成后，再执行后续代码。<br>异步 <code>I/O</code> ：在代码中的表现，就是代码<strong>不暂停执行</strong> I/O 操作，后面的代码可以继续执行，当 I/O 操作执行完成后，通过<strong>回调函数</strong>的方式通知<code>CPU</code>，说<code>I/O</code>操作已经完成了，基于 I/O 操作结果的其他操作可以执行了（通知CPU调用回调函数）。</p><p>以上说明，同步<code>I/O</code>和异步<code>I/O</code>区别：就是<strong>是否等待</strong> I/O 结果。</p><p><code>Node</code>采用的就是<strong>异步非阻塞 I/O</strong> 模型。</p><h3 id="进程-与-线程"><a href="#进程-与-线程" class="headerlink" title="进程 与 线程"></a>进程 与 线程</h3><p>每当我们运行应用程序时，操作系统都会创建该应用程序的<strong>实例对象</strong>，该实例对象就是应用程序的<strong>进程</strong>，操</p><p>作系统会按照<strong>进程</strong>为<strong>单位</strong>为应用程序分配资源，比如内存，这样程序才能够在计算机的操作系统中运行起来。</p><p><strong>线程</strong>被包裏在进程之中，是进程中的实际运作单位，一条线程指的就是进程中的一个单一顺序的控制流。也就是</p><p>说，<strong>应用程序要做的事情都存储在线程之中</strong>。可以这样认为，一条线程就是一个待办列表， 供<code>CPU</code>执行。</p><h3 id="JavaScript-是单线程还是多线程-？"><a href="#JavaScript-是单线程还是多线程-？" class="headerlink" title="JavaScript 是单线程还是多线程 ？"></a>JavaScript 是单线程还是多线程 ？</h3><p>在<code>Node.js</code>代码运行环境中，它为<code>JavaScript</code>代码的执行提供了一个主线程，通常我们所说的单线程指的就是这个主线程，<strong>主线程</strong>用来<strong>执行</strong>所有的<strong>同步</strong>代码。</p><p>但是<code>Node.js</code>代码运行环境本身是由<code>C++</code>开发的，在<code>Node.js</code>内部它依赖了一个叫做<code>libuv</code>的<code>C++</code> 库，在这个库中它维护了一个线程池，默认情况下在这个线程池中存储了<code>4</code>个线程，<code>JavaScript</code> 中的<strong>异步代码</strong>就是在这些线程中执行的，所以说<code>JavaScript</code>代码的运行依靠了不止一个线程，所以<code>JavaScript</code>本质上还是<strong>多线程</strong>的。</p><p><code>JavaScript</code> 可以进行 同步 和 异步 的并发操作。</p><h2 id="基于回调函数的异步编程"><a href="#基于回调函数的异步编程" class="headerlink" title="基于回调函数的异步编程"></a>基于回调函数的异步编程</h2><p>回调函数：指通过函数<strong>参数的方式</strong>将一个函数传递到另一个函数中，参数函数就是<strong>回调函数</strong>。</p><p>回调函数写成<code>callback</code>， 实际上它是<code>call then back</code>的简写，含义是<strong>调用后返回</strong>,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"A is running' )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">function B(callback)&#123;</span></span><br><span class="line"><span class="string">    console.log("</span>B Start<span class="string">")</span></span><br><span class="line"><span class="string">    callback()    // A is running</span></span><br><span class="line"><span class="string">    console.log("</span>B End<span class="string">") </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">B(A)</span></span><br></pre></td></tr></table></figure><p>为什么在<code>B</code>函数中不直接调用<code>A</code>函数而要通过<strong>参数的方式</strong>传递进去?</p><blockquote><p>通常在编写应用程序时，<code>B</code>函数都是语言内部或者其他开发者定义好的，我们看不到内部代码或者说不能直接在他内部代码中插入我们的代码，而我们又想介入程序的执行，此时就可以通过<strong>回调函数的方式</strong>将我们的逻辑传递给<code>B</code>函数，<code>B</code>函数在内部再来调用这个回调函数。</p></blockquote><h2 id="回调函数在异步编程中的应用"><a href="#回调函数在异步编程中的应用" class="headerlink" title="回调函数在异步编程中的应用"></a>回调函数在异步编程中的应用</h2><p>在异步编程中，异步<code>API</code>执行的结果是通过回调函数传递参数的方式传递到上层代码中的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"./index.html"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"发生了错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>回调地狱是回调函数<strong>多层嵌套</strong>导致代码难以维护的问题。</p><p>基于回调函数的异步编程不小心会产生回调地狱的问题。</p><p>需求：一次读取 x.txt、y.txt、z.txt 三个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">" ./x.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, x</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(<span class="string">"./y.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(<span class="string">" ./z.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, z</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(z)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上，读取文件异步 I/O 操作，不一定按照顺序返回。因此，改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"'s"</span>)</span><br><span class="line">fs.readFile(<span class="string">" ./x.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    fs.readFile(<span class="string">"./y.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, y</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y)</span><br><span class="line">        fs.readFile(<span class="string">" ./z.txt"</span>, <span class="string">"ttf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, z</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(z)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基于promise-的异步编程"><a href="#基于promise-的异步编程" class="headerlink" title="基于promise 的异步编程"></a>基于promise 的异步编程</h2><p><code>Promise</code>是<code>JavaScript</code>中异步编程解决方案，可以解决回调函数方案中的回调地狱问题。</p><p>可以将<code>Promise</code>理解为<strong>容器</strong>，用于<strong>包裹异步 API 的容器</strong>，当容器中的异步<code>API</code>执行完成后，<code>Promise</code>允许我们在</p><p>容器的外面获取异步<code>API</code>的执行结果，从而避免回调函数嵌套。</p><p><code>Promise</code>翻译为承诺，表示它承若帮我们做一些事情，既然它承若了它就要去做，做就会有一个过程，就会有一</p><p>个结果，结果要么是成功，要么是失败。</p><p>所以在Promise中有三种状态：分别为等待(<code>pending</code>)，成功(<code>fulfilled</code>)， 失败(<code>rejected</code>)。</p><p>默认状态为等待，等待可以变为成功，等待可以变为失败。</p><p>状态一旦更改不可改变，成功不能变回等待，失败不能变回等待，成功不能变成失败，失败不能变成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="comment">// 调用 Promise ,它执行器（包裹的代码）被立即执行</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">"./x.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error)&#123;</span><br><span class="line">    <span class="comment">// 将状态从等待变为失败</span></span><br><span class="line">    reject(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将状态从等待变为成功</span></span><br><span class="line">    resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;.finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>promise</code> 使用<code>resolve</code>将<strong>等待</strong>状态变为<strong>成功</strong>状态, <code>reject</code>将<strong>等待</strong>状态变为<strong>失败</strong>状态。并且将成功或者失败状态传递到外部。</p><blockquote><p>注意：</p><p>1、只要链式调用出现错误，就不会向下执行，直接传递错误参数给 <code>catch</code>函数；</p><p>2、链式调用中还有一个函数<code>finally</code>（最后的），不管成功、失败都会执行，该函数<strong>回调函数</strong>没有<strong>参数</strong></p></blockquote><h3 id="并发异步操作"><a href="#并发异步操作" class="headerlink" title="并发异步操作"></a>并发异步操作</h3><p><code>all</code>方法，该方法接收数组形式的参数，每个元素必须是 <code>promise</code> 对象</p><p>先定义异步函数 <code>readFile</code>，该函数返回<code>promise</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span> (<span class="params">resovle, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(path, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resovle(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用 <code>all</code>函数并发执行三个异步操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    readFile(<span class="string">"/x.txt"</span>),</span><br><span class="line">    readFile(<span class="string">"/y.txt"</span>), </span><br><span class="line">    readFile(<span class="string">"/z.txt"</span>)</span><br><span class="line">    ]).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印出：</span></span><br><span class="line"><span class="comment">// x.txt的内容 </span></span><br><span class="line"><span class="comment">// y.txt的内容</span></span><br><span class="line"><span class="comment">// z.txt的内容</span></span><br></pre></td></tr></table></figure><h3 id="异步函数解决代码臃肿"><a href="#异步函数解决代码臃肿" class="headerlink" title="异步函数解决代码臃肿"></a>异步函数解决代码臃肿</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数  封装成 异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"> </span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数  封装成 异步函数</span></span><br><span class="line"><span class="keyword">const</span> fn=<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数的返回值被 <code>promise</code>包裹，使得该方法可以使用链式调用：then 方法</p><p><code>await</code> 关键字：等待异步操作执行后，再向下执行。不会阻塞主线程（<strong>不会阻塞同步代码</strong>），只会在 C++ 开发的 线程池中的线程中执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> X = <span class="keyword">await</span> readFile(<span class="string">"./x.txt"</span>) </span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">await</span> readFile(<span class="string">"./y.txt"</span>)</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">await</span> readFile(<span class="string">"./z.txt"</span>)</span><br><span class="line">    <span class="keyword">return</span> [x,y,z]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前调用三个异步操作的代码进行比较：</p><p>1、promise 方法调用方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br><span class="line"><span class="keyword">return</span> readFile(<span class="string">"./y.txt"</span>) </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(y)</span><br><span class="line"><span class="keyword">return</span> readFile(<span class="string">"./z.txt"</span>) </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(z)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、回调地狱方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">" ./x.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    fs.readFile(<span class="string">"./y.txt"</span>, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, y</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y)</span><br><span class="line">        fs.readFile(<span class="string">" ./z.txt"</span>, <span class="string">"ttf-8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, z</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(z)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>await</code>解决了链式调用和回调地狱代码臃肿问题</p><h3 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h3><p><code>util</code>包中的<code>promisify</code> 方法可以将函数返回值封装为 <code>promise</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">"util"</span>).promisify</span><br><span class="line"><span class="comment">// 将 fs.readFile方法返回数据 封装为 promise 对象</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> X = <span class="keyword">await</span> readFile(<span class="string">"./x. txt"</span>, <span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">await</span> readFile(<span class="string">"./y. txt"</span>, <span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">await</span> readFile(<span class="string">"./z. txt"</span>, <span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> [x, y, z]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了可以封装函数返回值为<code>promise</code>对象 的方法，就不用自定义返回类型为<code>promise</code> 类型的函数了。</p><h2 id="Event-Loop-机制概述"><a href="#Event-Loop-机制概述" class="headerlink" title="Event Loop 机制概述"></a>Event Loop 机制概述</h2><p>1、为什么要学习事件循环机制 ?</p><p>学习事件循环可以明白<code>JavaScript</code>的运行机制。</p><p>2、事件循环机制做的是什么事情 ?</p><p>事件循环机制用于<strong>管理</strong>异步<code>API</code>的<strong>回调函数</strong>什么时候回到<strong>主线程</strong>中执行。</p><p><code>Node.js</code>采用的是异步<code>I/O</code>模型。</p><p>同步<code>API</code>在主线程中执行，异步<code>API</code>在底层的<code>C++</code>维护的线程中执行，异步<code>API</code>的<strong>回调函数</strong>在<strong>主线程</strong>中执行。在<code>JavaScript</code>应用运行时，众多异步<code>API</code>的<strong>回调函数</strong>什么时候能回到主线程中调用 ? 这就是事件循环机制做的事。</p><p>3、为什么这种机制叫做事件循环?</p><p>因为<code>Node.js</code>是事件驱动的。事件驱动就是当什么时候做什么事情，做的事情定义在回调函数中，可以将异步<code>API</code>的<strong>回调函数</strong>理解为<strong>事件处理函数</strong>，所以管理异步<strong>API</strong>回调函数什么时候回到主线程中调用的机制叫做事件循环机制。</p><h3 id="Event-Loop-六个阶段"><a href="#Event-Loop-六个阶段" class="headerlink" title="Event Loop 六个阶段"></a>Event Loop 六个阶段</h3><p><a href="https://www.bilibili.com/video/BV1Cg411A74L/?spm_id_from=pageDriver&vd_source=97637b96c4294f5b0f10fdcfcfe59d55" target="_blank" rel="noopener">学习视频</a></p><p>事件循环就是一个循环体，在循环体中有六个阶段，在每个阶段都有一个事件队列，不同事件队列中存储不同的异步<code>API</code>的<strong>回调函数</strong>。</p><p>【timer】：用于存储定时器的回调函数（<code>setlnterval</code>, <code>setTimeout</code>）。</p><p>【pending callback】：执行与操作系统相关的回调函数，比如启动服务器端应用时，监听端口操作的回调函数就在这里调用。</p><p>【Idle / prepare】：系统内部使用。</p><p>【I/O poll】：</p><p>【check】：存储<code>setImmediate</code> API 的回调函数</p><p>【Closing callbacks】：执行与<strong>关闭事件</strong>相关的回调函数，例如关闭数据库连接的回调函数等。</p><h2 id="宏任务-VS-微任务"><a href="#宏任务-VS-微任务" class="headerlink" title="宏任务 VS 微任务"></a>宏任务 VS 微任务</h2><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>宏任务（macrotask）: setlnterval、setTimeout、 setlmmediate、 I/O</p><p>微任务（microTask）: Promise.then、 Promise.catch 、Promise.finally、 process.nextTick</p><h3 id="微任务与宏任务的区别"><a href="#微任务与宏任务的区别" class="headerlink" title="微任务与宏任务的区别"></a>微任务与宏任务的区别</h3><p>1、微任务的回调函数被放置在微任务队列中，宏任务的回调函数被放置在宏任务队列中。</p><p>2、微任务优先级高于宏任务。</p><p>① 当微任务事件队列中存在可以执行的回调函数时，事件循环在执行完当前阶段的回调函数后会暂停进入事件循</p><p>环的下一个阶段，事件循环会<strong>立即进入</strong>微任务的事件队列中开始执行回调函数，当微任务队列中的回调函数执行完</p><p>成后，事件循环再进入到下一个阶段开始执行回调函数。</p><p>② <code>nextTick</code>的优先级高于<code>microTask</code>。在执行任务时，只有<code>nextTick</code>中的所有回调函数执行完成后才会开始执</p><p>行其他<code>microTask</code>。不同阶段的宏任务的回调函数被放置在了不同的宏任务队列中，宏任务与宏任务之间没有优先级</p><p>的概念，他们的执行顺序是按照事件循环的阶段顺序进行的。</p><h3 id="Event-Loop-代码解析"><a href="#Event-Loop-代码解析" class="headerlink" title="Event Loop 代码解析"></a>Event Loop 代码解析</h3><p>在<code>node</code>应用程序启动 后，并不会立即执行进行事件循环，而是先执行输入代码，从上到下开始执行，同步执行<code>API</code>会立即执行，异步<code>API</code>交给C++维护的线程执行。异步<code>API</code>的回调函数被注册到事件队列中，<strong>当所有输入代码执行完成后，开始进入事件循环</strong>。</p><p>验证事件循环机制（1）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br><span class="line">setTimeout() =&gt;&#123;</span><br><span class="line"><span class="built_in">console</span> .log(<span class="string">"setTimeout 1"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout() =&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"setTimeout 2"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>)</span><br><span class="line"><span class="comment">// start end 1 2</span></span><br></pre></td></tr></table></figure><p>代码从上到下执行：第一行执行，并立即打印，第一个<code>setTimeout</code>执行，将回调函数放到事件队列中，第二个<code>setTimeout</code>执行，将回调函数注册到事件队列中，最后一行立即执行，并打印。进入事件队列，<code>timer</code> 阶段，处理<code>setTimeout</code>的回调函数，队列按照先进先出。</p><p>验证事件循环机制（2）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"1"</span>), <span class="number">0</span>) </span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"2"</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start &lt; delay)&#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//1 2</span></span><br></pre></td></tr></table></figure><p>代码从上到下执行，<code>setTimeout</code>的回调函数注册到<code>timers</code>事件队列中，<code>setImmediate</code>回调函数被注册到<code>check</code>事件队列中，<code>sleep(1000)</code>立即执行，阻塞<strong>主线程</strong><code>1000ms</code>后结束，接下来进入事件循环，先执行<code>timers</code> 阶段，再执行<code>check</code>阶段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"1"</span>), <span class="number">0</span>) </span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"2"</span>))</span><br><span class="line"><span class="comment">// 结果不一定，存在两种可能：1 2  、2 1</span></span><br></pre></td></tr></table></figure><p><code>node.js</code> 中<code>setTimeout</code>的时间参数为<code>0</code>时，会被强制改为 <code>1</code> ，进入事件循环的时间没到 1时， 事件循环会进入下一个阶段，继续循环。直到时间到了执行。</p><p>验证事件循环机制（3）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span> )</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"./index.htmt"</span>, ( ) =&gt; </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"1"</span>),，<span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"2"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2 1</span></span><br></pre></td></tr></table></figure><p>代码从上到下执行，执行<code>readFile</code>将回调函数放入线程池中的线程中。同步代码执行完毕后，进入事件循环队列。到了 <code>I/O POLL</code>阶段，将回调函数 <code>setTimeout</code>、<code>setImmediate</code>注册到 <code>timer</code> 、<code>check</code> 事件队列中，执行当前队列进入下一个事件队列 <code>check</code>，处理完并清空队列后，进入<code>timer</code>队列处理回调。</p><p>验证事件循环机制（4）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>) )</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>) )</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>) )</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))()</span><br><span class="line"><span class="comment">// 5 3 4 1 2</span></span><br></pre></td></tr></table></figure><p>从上到下依次执行代码，<code>setTimeout</code>执行，回调被注册到事件队列 <code>timer</code>中，<code>setImmediate</code>执行，回调被注册到事件队列<code>check</code>中，<code>process.nextTick()</code>执行，回调被注册到微任务队列中，<code>Promise.resolve().then()</code>执行，回调被注册到微任务队列中，立即执行函数执行，并打印结果 <code>5</code>。优先级微任务&gt;宏任务，微任务中<code>nextTick()</code>优先级&gt;其他微任务优先级。先输出 <code>3</code>，再输出 <code>4</code>，事件循环从<code>timer</code>开始 处理回调 ，输出 <code>1</code>，<code>check</code>阶段处理回调，输出 <code>2</code>。</p><p>验证事件循环机制（5）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick() =&gt; <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then() =&gt; <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">process.nextTick() =&gt; <span class="built_in">console</span>.log(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then() =&gt; <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 1 3 2 4</span></span><br></pre></td></tr></table></figure><p>以上四个回调函数都属于微任务队列，<code>nextTick</code>优先级高于其他微任务，并且根据栈的先进先出得出结果。</p><p>验证事件循环机制（6）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"1"</span>), <span class="number">50</span>) </span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"2"</span>)) </span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"3"</span>))</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"4"</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//2 3 1 4</span></span><br></pre></td></tr></table></figure><p>从<strong>上到下执行</strong>后，setTimeout、process.nextTick、setImmediate、process.nextTick 将回调函数注册到进任务队列。首先<strong>执行微任务</strong>，输出 <code>2</code>， 第二个微任务的回调函数<code>setTimeout</code> 注册到<code>timer</code>任务队列，进入<strong>事件循环</strong>，时间还未到 50 ，则执行下一个栈、直到<code>check</code>执行并输出<code>3</code>，最后输出 <code>1</code>、<code>4</code></p><p>结论：<code>Node</code>适合<code>I/O</code>密集型任务，不适合<code>CPU</code>密集型任务，因为主线程一旦阻塞，程序就卡主了。</p><h1 id="开发环境说明"><a href="#开发环境说明" class="headerlink" title="开发环境说明"></a>开发环境说明</h1><p>在开发环境中，开发者机器既充当了<strong>客户端</strong>的角色又充当了<strong>服务器</strong>的角色。<br>本机IP：127.0.0.1<br>本机域名：localhost</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 版本管理</title>
      <link href="/2022/09/03/git%20%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <url>/2022/09/03/git%20%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><center>Git</h1><blockquote><p>注：&lt;文件&gt;：表示某文件名带后缀</p></blockquote><h2 id="常用查看信息"><a href="#常用查看信息" class="headerlink" title="常用查看信息"></a>常用查看信息</h2><ol><li><p>git status  查看<strong>是否</strong> track 、modified</p></li><li><p>git log  查看<strong>提交全部</strong>历史的时间线、提交号</p></li><li><p>git diff  &lt;文件&gt; 查看某文件<strong>内容更改细节</strong></p></li><li><p>git reflog   查看 提交号、提交备注</p></li></ol><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ol><li><p>取消追踪（删除<strong>版本库</strong>的指定文件 ）</p><p>git rm &lt;文件&gt; </p><blockquote><p>示例：</p><p>git rm –cached &lt;file&gt;  删除 <code>&lt;file&gt;</code>的跟踪，并保留在本地。</p><p>git rm –f  &lt;file&gt;  删除 <code>&lt;file&gt;</code>的跟踪，并且删除本地文件。</p></blockquote><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></li><li><p>创建分支</p><p>创建本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>创建并提交到远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; 本地分支A:远程分支B</span><br></pre></td></tr></table></figure></li><li><p>查看分支</p><p>查看本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>查看远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show &lt;远程仓库名&gt;</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><p>本地切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><p>先切换到别的分支才能当前分支</p><p>删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>删除远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; --delete 分支名</span><br></pre></td></tr></table></figure></li><li><p>提交分支</p><p>本地<code>A</code>分支提交到远程<code>B</code>分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; 本地分支A:远程分支B</span><br></pre></td></tr></table></figure></li><li><p>跟踪分支</p><p>从远程仓库中，把对应远程分支下载到本地仓库，保持本地分支和远程分支<strong>名称相同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>从远程仓库中，把对应远程分支下载到本地仓库，并对本地分支<strong>重命名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;本地分支名&gt; &lt;远程仓库名&gt;&#x2F;&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>拉取远程分支</p><p>从远程仓库，拉取<strong>当前分支</strong>最新的代码，保持当前分支的代码和远程分支代码<strong>一致</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><p>注意：假设要把<code>C</code>分支代码合并到<code>A</code>分支，则必须先切换到<code>A</code>分支上，再运行一下<code>git merge</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;C分支&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改文件后提交到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;修改的某文件&gt;</span><br><span class="line">git commit -m &quot;备注&quot;</span><br><span class="line">git push &lt;远程仓库名&gt; &lt;远程仓库分支&gt;</span><br></pre></td></tr></table></figure></li><li><p>取消暂存的文件（已经add的文件，取消<strong>track</strong>）</p><p>git reset HEAD &lt;文件&gt;</p><blockquote><p>git <a href="https://so.csdn.net/so/search?q=reset&spm=1001.2101.3001.7020" target="_blank" rel="noopener">reset</a> –soft HEAD~n ,撤销最近n个提交，变成add状态，可以重新commit</p></blockquote></li><li><p><strong>版本库</strong>里指定文件替换<strong>工作区</strong>里同名文件</p><p>git checkout  –&lt;文件&gt;  </p><p><em>以上代码很危险</em></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array 最大值</title>
      <link href="/2022/09/03/Array%20%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2022/09/03/Array%20%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="定义原数组"><a href="#定义原数组" class="headerlink" title="定义原数组"></a>定义原数组</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">30</span>]</span><br></pre></td></tr></table></figure><p>以下实验对象是 <code>arr</code></p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr)) </span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort 方法"></a>sort 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a)</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式相关内容</title>
      <link href="/2022/09/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
      <url>/2022/09/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a><center>RegExp</h1><h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><p>1、简洁模式创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags</span><br></pre></td></tr></table></figure><blockquote><p>pattern (模式)：包括字符类、限定符、分组、向前查找、反向引用</p><p>flags (标记)：可以为 0 个或多个 ，控制正则表达式行为</p></blockquote><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\w/g</span></span><br></pre></td></tr></table></figure><p>2、<code>RegExp</code>构造函数创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern,flags)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w"</span>,<span class="string">"g"</span>)</span><br></pre></td></tr></table></figure><p>3、以上两种创建方式的区别：</p><p>（1）<strong>构造函数</strong>的<code>pattern</code> 字符串需要增加转义：</p><p>【不同身份的字符串】JavaScript 中的字符串有不同的身份，和人类身份类似（可以是老师的学生、家长的孩子、对象的女朋友），带到正则表达式中，也是这样如下：</p><blockquote><p><code>.</code>   是除换行外任意字符，<code>\.</code>是匹配普通点</p><p><code>d</code>是匹配字符串，<code>\d</code>是数字<code>0-9</code></p><p>注意：</p><p>在<strong>字符串</strong>中 <code>\d</code> ==  <code>d</code> ，又因为<code>RegExp</code>构造函数的第一个参数是字符串，需要经过转义，因此，  <code>\</code> 转义写成 <code>\\</code> 、 <code>\\</code> 转义写成 <code>\\\\</code> </p><p>技巧：不知道编写的表达式是否正确，可以使用<code>console.log</code>打印查看机器理解的真正的含义</p></blockquote><p>（2）<strong>构造函数</strong>的<code>pattern</code> 没有开始和结束符号。</p><h2 id="字符含义"><a href="#字符含义" class="headerlink" title="字符含义"></a>字符含义</h2><p>表1</p><table><thead><tr><th>符号</th><th></th><th>示例</th></tr></thead><tbody><tr><td>^</td><td>起始</td><td>从起始位置进行匹配</td></tr><tr><td>$</td><td>结束</td><td></td></tr><tr><td>{}</td><td>匹配的数量（长度）</td><td>{3,6} 匹配3到6位</td></tr><tr><td>[]</td><td>可选</td><td></td></tr><tr><td>+</td><td>一个或多个</td><td>/d+ 匹配一个或多个数字</td></tr><tr><td>.</td><td>除了换行符</td><td></td></tr><tr><td>*</td><td>0或多个</td><td></td></tr></tbody></table><p>表2</p><table><thead><tr><th>元字符</th><th>匹配</th><th>示例</th></tr></thead><tbody><tr><td>/s</td><td>空白</td><td>空格” “、换行”\n“</td></tr><tr><td>/S</td><td>除了空白</td><td></td></tr><tr><td>/d</td><td>数字</td><td></td></tr><tr><td>/D</td><td>除了数字</td><td></td></tr><tr><td>/w</td><td>字母、数字、下划线</td><td></td></tr><tr><td>/W</td><td>除了字母、数字、下划线</td><td></td></tr><tr><td>.</td><td>除了换行符</td><td></td></tr></tbody></table><p>表3 模式修正符</p><table><thead><tr><th>模式修正符</th><th>行为</th></tr></thead><tbody><tr><td>g</td><td>全局</td></tr><tr><td>i</td><td>忽略大小写</td></tr><tr><td>s</td><td>忽略换行</td></tr></tbody></table><h1 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h1><h2 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h2><p><strong><code>exec()</code></strong> 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <code>null</code></p><blockquote><p>【语法】：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(str)</span><br></pre></td></tr></table></figure><p>【参数】：要匹配正则表达式的字符串</p><p>【返回值】：</p><p>如果匹配失败，<code>exec()</code> 方法返回 <code>null</code>，并将正则表达式的 <code>lastIndex</code> 重置为 0 。</p><p>如果匹配成功，<code>exec()</code> 方法返回一个数组，并更新正则表达式对象的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener"><code>lastIndex</code></a> 属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应一个匹配的捕获组。数组还具有以下额外的属性：</p><p>index：匹配到的字符位于原始字符串的基于 0 的索引值。</p><p>input：匹配的原始字符串。</p><p>groups：一个命名捕获组对象，其键是名称，值是捕获组。若没有定义命名捕获组，则 <code>groups</code> 的值为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Backreferences" target="_blank" rel="noopener">捕获组</a>以了解更多信息。</p><p><code>indices</code> 可选：此属性仅在设置了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/hasIndices" target="_blank" rel="noopener">d (en-US)</a> 标志位时存在。它是一个数组，其中每一个元素表示一个子字符串的边界。每个子字符串匹配本身就是一个数组，其中第一个元素表示起始索引，第二个元素表示结束索引。</p></blockquote><h2 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h2><p><strong><code>test()</code></strong> 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexObj.test(str)</span><br></pre></td></tr></table></figure><p>参数：用来与正则表达式匹配的字符串</p><p>返回值：如果正则表达式与指定的字符串匹配 ，返回<code>true</code>；否则<code>false</code>。</p><h1 id="相关使用"><a href="#相关使用" class="headerlink" title="相关使用"></a>相关使用</h1><h2 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h2><p><strong><code>replace()</code></strong> 方法返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。原字符串不改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="string">"1 2 1 2 1 2 1 2"</span></span><br><span class="line"><span class="built_in">console</span>.log(p.replace(<span class="string">'1'</span>, <span class="string">'2'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/1/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.replace(regex, <span class="string">'2'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt; "2 2 1 2 1 2 1 2"  匹配一次</span></span><br><span class="line"><span class="comment">&gt; "2 2 2 2 2 2 2 2"  /.../g 替换全部</span></span><br><span class="line"><span class="comment">&gt; "1 2 1 2 1 2 1 2"  p 没改变</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>【语法】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(regexp|substr, newSubStr|<span class="function"><span class="keyword">function</span>)</span></span><br></pre></td></tr></table></figure><p>【第一个参数（pattern）】：是正则表达式<code>regexp</code>，或者字符串<code>string</code></p><p>【第二个参数（replacement）】：是字符串，或者函数<code>function</code></p><p>【返回值】：一个部分或全部匹配由替代模式所取代的<strong>新的字符串</strong>。</p><blockquote><p>注意：</p><p>如果第一个参数<code>（pattern）</code>是正则表达式，并且其为全局匹配模式（flags为 <code>g</code>），那么这个方法将被多次调用，每次匹配都会被调用。</p></blockquote><h2 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h2><p><strong><code>match()</code></strong> 方法检索返回一个字符串匹配正则表达式的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> paragraph = <span class="string">'The quick brown fox jumps over the lazy dog. It barked.'</span>;</span><br><span class="line"><span class="keyword">const</span> regex1 = <span class="regexp">/[A-Z]/</span>;</span><br><span class="line"><span class="keyword">const</span> regex2 = <span class="regexp">/[A-Z]/g</span>;  <span class="comment">// 匹配大写字母</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(paragraph.match(regex1));</span><br><span class="line"><span class="built_in">console</span>.log(paragraph.match(regex2));</span><br><span class="line"><span class="comment">// output: Array ["T", "I"]</span></span><br><span class="line"><span class="comment">// output: Array ["T"]</span></span><br></pre></td></tr></table></figure><p>【语法】str.match(regexp)</p><p>【参数（regexp）】一个<strong>正则表达式</strong>对象，如果传入一个非正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <code>RegExp</code> 。</p><p>【返回值】</p>]]></content>
      
      
      <categories>
          
          <category> RegExp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题（http 部分） (2)</title>
      <link href="/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88http%20%E9%83%A8%E5%88%86%EF%BC%89%20(2)/"/>
      <url>/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88http%20%E9%83%A8%E5%88%86%EF%BC%89%20(2)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经（JavaScript　部分）</title>
      <link href="/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88JavaScript%20%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88JavaScript%20%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><center>JavaScript</h1><h1 id="数据类型与数值"><a href="#数据类型与数值" class="headerlink" title="数据类型与数值"></a>数据类型与数值</h1><h2 id="原始类型、引用类新型有哪些-？"><a href="#原始类型、引用类新型有哪些-？" class="headerlink" title="原始类型、引用类新型有哪些 ？"></a>原始类型、引用类新型有哪些 ？</h2><p>原始（基本）数据类型有 6 种(注意全是小写)：</p><ul><li><input disabled="" type="checkbox"> number</li><li><input disabled="" type="checkbox"> boolean</li><li><input disabled="" type="checkbox"> string</li><li><input disabled="" type="checkbox"> null</li><li><input disabled="" type="checkbox"> undefined</li><li><input disabled="" type="checkbox"> Symbol</li></ul><p>引用类型：</p><ul><li><input disabled="" type="checkbox"> 对象类型 Object ：普通对象 Object , Date、Array、Function 、Date 、RegExp 、Error… , <code>Number、String、Boolean（基本包装类型）</code> </li></ul><p>总结以上，一共有 7 种数据类型。</p><h2 id="说出以下代码运行结果和原因-？"><a href="#说出以下代码运行结果和原因-？" class="headerlink" title="说出以下代码运行结果和原因 ？"></a>说出以下代码运行结果和原因 ？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">       person.age = <span class="number">26</span></span><br><span class="line">       person = &#123;</span><br><span class="line">           name:<span class="string">'hh'</span></span><br><span class="line">           age:<span class="string">'18'</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> person</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> p1 = &#123;</span><br><span class="line">         name:<span class="string">'ff'</span></span><br><span class="line">         age:<span class="string">'20'</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> p2 = test(p1)</span><br><span class="line">   <span class="built_in">console</span>.log(p1) <span class="comment">// --&gt;</span></span><br><span class="line">   <span class="built_in">console</span>.log(p2) <span class="comment">// --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><p>p1：{name: “ff”, age: 26}<br>p2：{name: “hh”, age: 18}</p><p><strong>原因：</strong><br>引用类型作为实参，在函数传参时传递的是内存地址值，p1 将地址传递给 person，person 更改了 p1 引用地址中的内容，又给其重新分配引用地址，并将地址值传递给 p2 </p><h2 id="null-是对象吗-？"><a href="#null-是对象吗-？" class="headerlink" title="null 是对象吗 ？"></a>null 是对象吗 ？</h2><p><strong>结论：</strong><br>null 不是对象</p><p><strong>原因：</strong><br>虽然 typeof 测试 null 的类型输出为 Object，但是这是 JS 的一个 bug ，因为 JS 初创时使用的是 32 位系统，考虑到性能，JS 采用低位存储变量的类型，对象类型的二进制是以 000 开头的，而 null 的二进制是全 0，则 typeof 输出 Object 的错误结果</p><h2 id="‘1’-toString-为什么能调用-？"><a href="#‘1’-toString-为什么能调用-？" class="headerlink" title="‘1’.toString( ) 为什么能调用 ？"></a>‘1’.toString( ) 为什么能调用 ？</h2><p>虽然 toString( ) 是对象方法，但是因为<strong>基本包装类型</strong>的特性，该语句执行其实做了几件事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new String（'1'） 可用，ES6不建议使用new关键字创建基本类型的包装类</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Object</span>（<span class="string">'1'</span>） </span><br><span class="line">s.toString ()</span><br><span class="line">s = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>其中三种基本类型：Boolean，Number，String 又是基本包装类型。基本包装类型是将 <strong>简单数据类型</strong> 包装成 <strong>复杂数据类型</strong>。因此可以调用系统方法。<br>第一步：创建对象实例<br>第二步：调用对象方法<br>第三步：执行完对象方法立即销毁对象</p><h2 id="0-1-0-2-0-3-，为什么-？"><a href="#0-1-0-2-0-3-，为什么-？" class="headerlink" title="0.1+0.2 != 0.3 ，为什么 ？"></a>0.1+0.2 != 0.3 ，为什么 ？</h2><p>浮点数 0.1 和 0.2 转为二进制时，是无限循环的值，计算机因为资源有限将其表示为近似值，因此出现精度损失。最后将相加的结果再转为 10 进制输出，结果为 0.30000000000000004</p><h2 id="什么是-BigInt-？"><a href="#什么是-BigInt-？" class="headerlink" title="什么是 BigInt ？"></a>什么是 BigInt ？</h2><p>BigInt 是第二种数字数据类型，当整数超过 Number 支持的范围时使用，该数据类型允许我们安全的使用大整数执行算术操作，能表示高分辨率时间戳，使用大整数 ID 等等，而不用调用库</p><h3 id="为什么需要-BigInt-？"><a href="#为什么需要-BigInt-？" class="headerlink" title="为什么需要 BigInt ？"></a>为什么需要 BigInt ？</h3><p>因为 Number 无法精确表示非常大的整数，在 JS 中，所有数字都是双精度 64 位浮点数表示，确切的说，JS 中 Number 类型只能安全表示 -(2^53-1)~(2^53-1) 范围的数值，会将非常大的整数四舍五入，在任何超出此范围的整数都会失去精度：</p><blockquote><p>console.log(9999 9999 9999 999) -&gt; 1000 0000 0000 0000<br>console.log(9007199254740992 === 9007199254740993) -&gt;true</p></blockquote><p>Math.pow (2, 53) 竟然与 Math.pow(2, 53) + 1 相等，则安全范围是：-(2^53-1)~(2^53-1)</p><h3 id="如何创建并使用-BigInt-？"><a href="#如何创建并使用-BigInt-？" class="headerlink" title="如何创建并使用 BigInt ？"></a>如何创建并使用 BigInt ？</h3><p>两种方式：</p><ul><li><input disabled="" type="checkbox"> 在数字末尾添加 n 就可以</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">9007199254740995n</span>) <span class="comment">//9007199254740995n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9007199254740995</span>) <span class="comment">//9007199254740996</span></span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 使用 BigInt() 构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="string">"9007199254740995"</span>)   <span class="comment">//9007199254740995n</span></span><br></pre></td></tr></table></figure><p>简单使用：</p><blockquote><p>10n + 20n; &emsp; // 30n<br>10n - 20n;  &emsp; //-10n<br>+10n;      &emsp;&emsp; //TypeError<br>-10n;        &emsp;&emsp; //-10n<br>10n* 20n    &emsp;//200n<br>20n / 10n   &emsp;//2n<br>23n % 10n &emsp;//3n<br>10n ** 3n  &emsp;//1000n</p></blockquote><blockquote><p>const x= 10n;<br>++x; &emsp;// 11n<br>–x;  &emsp; // 9n<br>console.log(x)  // bigint</p></blockquote><p><strong>注意：</strong></p><p>1) BigInt 不支持一元加号运算符，这可能是某些程序可能依赖于 + 始终生成 Number 类型，或者抛出异常，另外，更改 + 的行为也会破坏 asm.js 代码；<br>2) 不允许 BigInt 和 Number 之间进行混合操作，因为隐式类型转换可能会丢失信息；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">10n</span>; <span class="comment">// → TypeError</span></span><br></pre></td></tr></table></figure><p>3) 不能将 BigInt 传递给 Web API 和 JS 内置方法，这些函数需要 Number 类型；<br>4) 当 Boolean 和 BigInt 相遇时，和 Number 类似，除了 0n 为 false，其他值为 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0n</span>)&#123;</span><br><span class="line"><span class="comment">//条件判断为false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">3n</span>)&#123;</span><br><span class="line"><span class="comment">//条件为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 元素都为 BigInt 的数组都可以进行 sort；<br>6) BigInt 可以进行位运算。</p><h3 id="typeof-是否能正确判断类型-？"><a href="#typeof-是否能正确判断类型-？" class="headerlink" title="typeof 是否能正确判断类型 ？"></a>typeof 是否能正确判断类型 ？</h3><p>对于<strong>原始类型</strong>来说，除了 null 都可以调用 typeof 显示正确的类型：</p><blockquote><p>typeof 1 // ‘number’<br>typeof ‘1’ // ‘string’<br>typeof undefined // ‘undefined’<br>typeof true // ‘boolean’<br>typeof Symbol() // ‘symbol’</p></blockquote><p>对于<strong>引用数据</strong>类型，除了 function 类型，其他都输出Object：</p><blockquote><p>typeof [] // ‘Object’<br>typeof {} //‘Object’<br>typeof console.log //‘function’</p></blockquote><p>因此采用 typeof 判断对象数据类型不合适，而采用 instanceof 会更好。因为 instanceof 运算符用来检测构造函数的 prototype 属性是否出现在某个实例的 _<em>proto_</em> 对象原型上。</p><h3 id="instanceof-能否判断基本数据类型-？"><a href="#instanceof-能否判断基本数据类型-？" class="headerlink" title="instanceof 能否判断基本数据类型 ？"></a>instanceof 能否判断基本数据类型 ？</h3><p>instanceof 能判断，但是不能直接使用，需要重定义 instanceof 将其转换为使用 typeof 判断，方法如下：</p><ul><li>语法：<code>object instanceof constructor</code><ul><li><code>object</code>：某个实例对象</li><li><code>constructor</code>：某个构造函数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Symbol.hasInstance ：用于判断某对象是否为某构造器的实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance] (x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'number'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">111</span> <span class="keyword">instanceof</span> PrimitiveNumber )</span><br></pre></td></tr></table></figure><h3 id="能不能手动实现一下-instanceof-的功能-？"><a href="#能不能手动实现一下-instanceof-的功能-？" class="headerlink" title="能不能手动实现一下 instanceof 的功能 ？"></a>能不能手动实现一下 instanceof 的功能 ？</h3><p><strong>核心：</strong>原型链向上查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof (left,right)&#123;</span><br><span class="line">    &#x2F;&#x2F; 基本数据类型直接返回 false</span><br><span class="line">    if ( typeof left !&#x3D;&#x3D; &#39;object&#39; || left &#x3D;&#x3D;&#x3D; null )</span><br><span class="line">        return false;</span><br><span class="line">    &#x2F;&#x2F; getPrototypeof 是 object 对象自带的一个方法，能拿到参数的原型对象</span><br><span class="line">    let proto &#x3D; object.getPrototypeof (left);</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 查找到尽头，还没找到</span><br><span class="line">        if（proto &#x3D;&#x3D; null）return false;</span><br><span class="line">        &#x2F;&#x2F; 找到相同原型对象</span><br><span class="line">        if(proto &#x3D;&#x3D; right.prototype) return true;</span><br><span class="line">        proto &#x3D; object.getPrototypeof (proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="string">"11"</span>,<span class="built_in">String</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"11"</span>),<span class="built_in">String</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-is-和-的区别-？"><a href="#Object-is-和-的区别-？" class="headerlink" title="Object.is 和 === 的区别 ？"></a>Object.is 和 === 的区别 ？</h3><p>== 是等于， === 是<code>严格等于</code>，Object 是<code>加强版严格等于</code></p><p>Object.js() 的判断规则：和 === 基本一致，有两处不同：</p><ul><li>+0 不等于 -0</li><li>NaN 等于 NaN</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="number">-0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x === y)&#123;</span><br><span class="line">    <span class="comment">//1/0 === 1/0 返回 true ，1/+0 === 1/-0 返回 false</span></span><br><span class="line">        <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span>/x === <span class="number">1</span>/y;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//x !== y, x !== x 且 y !== y 都为 true，则两边都是 NaN </span></span><br><span class="line">        <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果是什么，为什么-？"><a href="#结果是什么，为什么-？" class="headerlink" title="[] == ![] 结果是什么，为什么 ？"></a>[] == ![] 结果是什么，为什么 ？</h3><p>优先级，！(逻辑非) &gt; == ，因此 ！将操作值转换成一个布尔值，然后对其取反：[] 是 <code>true</code> 转换成 ![] 是<code>false</code>；</p><p>逻辑非转换后，现在比较的是：[] == false；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>先看看相等操作符<code>==</code>的一些转换规则：</p><ul><li>如果有一个操作数是布尔值，则会先隐式调用<code>window</code>对象上的<code>Number</code>转型函数，将其转换为数值，<code>false</code>转为<code>0</code>，<code>true</code>转为<code>1</code>，再进行判断。</li><li>如果有一个操作数是字符串，另一个是数值，则隐式调用<code>Number</code>转型函数，将字符串转换为数值，再进行判断。</li><li>如果有一个操作数是对象，则调用对象的<code>valueOf</code>方法，如果返回的是<strong>复杂数据类型</strong>，则在返回值得基础上再调用<code>toString</code>方法，最后根据以上规则进行比较。</li></ul><p>分析<code>[] == ![]</code>得出以下思路：</p><ol><li>隐式调用<code>Boolean</code>转型函数，对空数组转换成<code>Boolean</code>值，再对结果取反。此时比较<code>[] == false</code>。</li><li>隐式调用<code>Number</code>转型函数，将<code>false</code>转换为数值<code>0</code>，此时比较<code>[] == 0</code>。</li><li>调用<code>valueOf</code>方法和<code>toString</code>方法，此时<code>[].toString()</code> 为空字符串，比较 <code>&#39;&#39; == 0</code>。</li><li>隐式调用<code>Number</code>转型函数，将空字符串转换为<code>0</code>，比较 <code>0 == 0</code>。</li><li>最后返回<code>true</code>。</li></ol><p>初步总结： == 转换<strong>最复杂</strong>的操作结果是转换为数值进行比较。对象类型转换为<code>[object Object]</code></p><h3 id="JS-中类型转换有几种-？"><a href="#JS-中类型转换有几种-？" class="headerlink" title="JS 中类型转换有几种 ？"></a>JS 中类型转换有几种 ？</h3><p>JS中，类型转换只有三种：</p><ul><li>转成 布尔值（调用 Boolean()方法）</li><li>转成 字符串（调用.toString()或 String()方法）</li><li>转成 数字（调用 Number(),parseInt(),parseFloat()方法）</li></ul><table>    <thead>        <td>原始值</td>             <td>转换目标</td>        <td>结果</td>      </thead>    <tbody>        <tr>            <td>number</td>                  <td rowspan="4">布尔值</td>                  <td>除了0、+-0、NaN 其他为 true</td>        </tr>        <tr>            <td>string</td>             <td>除了空串其他为 true</td>         </tr>        <tr>            <td>undefined、null</td>            <td>false</td>         </tr>        <tr>            <td>引用类型</td>            <td>true</td>         </tr>         <tr>            <td>number</td>            <td rowspan="4">字符串</td>             <td>0 => '0'</td>        </tr>        <tr>            <td>boolean、function、Symbol</td>            <td>'true'</td>        </tr>         <tr>            <td>数组</td>            <td>[1，2] => '1,2'</td>        </tr>        <tr>            <td>对象</td>            <td>’[object Object]‘</td>        </tr>        <tr>            <td>string</td>            <td rowspan="5">数字</td>            <td>'1' => 1;<br>'a' => NaN;<br>''=>0</td>        </tr>        <tr>            <td>数组</td>            <td>[] => 0;<br>有且仅有一个数字元素 => 数字;<br>其他 NaN</td>        </tr>         <tr>            <td>除了 Array 的其他引用类型</td>            <td>NaN</td>        </tr>        <tr>            <td>null</td>            <td>0</td>        </tr>         <tr>            <td>Symbol</td>            <td>抛错</td>        </tr>    </tbody></table><h3 id="和-的区别-？"><a href="#和-的区别-？" class="headerlink" title="== 和 === 的区别 ？"></a>== 和 === 的区别 ？</h3><p>== ：等于，两边值类型不同时，先进行类型转换，再比较；</p><p>===：严格等于，类型 + 值都相等时，才相等。<img src="https://img2018.cnblogs.com/i-beta/1888556/201912/1888556-20191215225956934-150507918.png" alt=""></p><h3 id="对象转原始（基本）类型是根据什么流程运行的-？"><a href="#对象转原始（基本）类型是根据什么流程运行的-？" class="headerlink" title="对象转原始（基本）类型是根据什么流程运行的 ？"></a>对象转原始（基本）类型是根据什么流程运行的 ？</h3><p>对象转原始类型，会调用内置的 ToPrimitive 函数，对于该函数而言，逻辑如下：</p><p><code>默认调用</code></p><p>如果有 Symbol.toPrimitive () 方法，优先调用再返回<br>其次调用 valueOf () ，如果转换为原始类型，则返回<br>其次调用 toString () ，如果转换为原始类型，则返回<br>如果都没有返回原始类型，会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'5'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>); <span class="comment">// 输出7</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'5'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>); <span class="comment">// 输出5</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>);  <span class="comment">// 输出[object Object]1</span></span><br></pre></td></tr></table></figure><h3 id="如何让-if-a-1-amp-amp-a-2-条件成立？"><a href="#如何让-if-a-1-amp-amp-a-2-条件成立？" class="headerlink" title="如何让 if(a == 1 &amp;&amp; a == 2) 条件成立？"></a>如何让 if(a == 1 &amp;&amp; a == 2) 条件成立？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">value:<span class="number">0</span>,</span><br><span class="line">valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a==<span class="number">1</span> &amp;&amp; a==<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h3 id="什么是闭包-？"><a href="#什么是闭包-？" class="headerlink" title="什么是闭包 ？"></a>什么是闭包 ？</h3><p>闭包就是：有权访问另一个函数作用域中的变量的函数。<br>函数嵌套函数，内部的函数就是闭包！</p><h3 id="闭包产生-？"><a href="#闭包产生-？" class="headerlink" title="闭包产生 ？"></a>闭包产生 ？</h3><ul><li>函数嵌套函数</li><li>函数内部使用外部函数的变量</li><li>调用外部函数</li></ul><h3 id="闭包的表现形式-？"><a href="#闭包的表现形式-？" class="headerlink" title="闭包的表现形式 ？"></a>闭包的表现形式 ？</h3><ul><li>返回一个函数</li><li>作为函数参数传递</li><li>使用回调函数</li><li>立即执行函数使用全局变量</li></ul><h3 id="解决闭包带来的缺点-？"><a href="#解决闭包带来的缺点-？" class="headerlink" title="解决闭包带来的缺点 ？"></a>解决闭包带来的缺点 ？</h3><ul><li>减少使用闭包</li><li>及时释放</li></ul><h3 id="如何解决下面的循环输出问题-？"><a href="#如何解决下面的循环输出问题-？" class="headerlink" title="如何解决下面的循环输出问题 ？"></a>如何解决下面的循环输出问题 ？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会全部输出 6 ？如何改进，让它输出 1，2，3，4，5 ？(方法越多越好)</p><p>因为 setTimeout 为宏任务，由于 js 单线程事件循环机制（EventLoop），在主线程同步任务执行完后才去执行宏任 务，因此循环结束后 setTimeout 中的回调才依次执行，但输出 i 的时候当前作用域没有，往上一级再找， 发现了 i ，此时循环已经结束，i 变成了 6 。因此会全部输出 6 。</p><p>解决方法：</p><p>1、利用 IIFE（立即执行函数表达式）当每次 for 循环时，把此时的 i 变量传递到定时器中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、给定时器传入第三个参数, 作为 timer 函数的第一个函数参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用 ES6 中的 let</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        注：let 使 JS 发生革命性的变化，让 JS 有函数作用域变为了块级作用域，用 let 后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例：</p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="原型对象和构造函数有何关系-？"><a href="#原型对象和构造函数有何关系-？" class="headerlink" title="原型对象和构造函数有何关系 ？"></a>原型对象和构造函数有何关系 ？</h2><p>在 JavaScript 中，每当定义一个函数数据类型（普通函数、类）时候，都会自带一个  prototype 属性， 这个属性指向函数的原型对象。当函数经过 new 调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个 proto 属性，指向构造函数的原型对象。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/176e00c8add949ec88cc91baddb657eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>注：实例与原型对象之间有直接的联系，但实例与构造函数之间没有。</p><h2 id="描述一下原型链-？"><a href="#描述一下原型链-？" class="headerlink" title="描述一下原型链 ？"></a>描述一下原型链 ？</h2><p>JavaScript 对象通过 <code>__proto__</code> 指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条, 即原型链。</p><p>原型是另一个原型的实例则会形成一条链，</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组去除重复元素有哪些方法-？"><a href="#数组去除重复元素有哪些方法-？" class="headerlink" title="数组去除重复元素有哪些方法 ？"></a>数组去除重复元素有哪些方法 ？</h2><p>1、利用 ES6 Set 去重；</p><p>2、利用 for 嵌套 for，然后 splice 去重；</p><p>3、利用 indexOf 去重；</p><p>4、利用 sort() 去重；</p><p>5、利用对象的属性不能相同的特点进行去重；</p><p>6、……</p><p>例：将下面数组去除重复元素（以多种数据类型为例）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="string">'abc'</span>, <span class="string">'abc'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>一、利用 ES6 Set 去重</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经（浏览器　部分）</title>
      <link href="/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%20%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%20%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="TCP-和-UDP-的区别-？"><a href="#TCP-和-UDP-的区别-？" class="headerlink" title="TCP 和 UDP 的区别 ？"></a>TCP 和 UDP 的区别 ？</h2><p><img src="https://img.php.cn/upload/image/183/308/585/1605056951790214.png" alt=""></p><p>基本上来说：TCP 是面向连接的、可靠的、基于字节流的传输层协议，UDP 是面向无连接的传输层协议。</p><p>与 UDP 的区别，主要体现在几个方面：</p><p>1、连接性</p><p>所谓连接，指的是客户端和服务器端的连接，进双方通信之前，TCP是需要进行 3 次握手建立连接，UDP 没有相应建立连接的过程。</p><p>2、单播、多播、广播的功能</p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能；</p><p>TCP 仅支持单播传输，每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p>3、可靠性</p><p>TCP 的可靠性主要体现在两个方面：一是有状态，二是可控制。</p><p>首先是有状态，TCP 是会记录哪些数据已发送，哪些数据对方是否接收到，而且会保证数据按顺序送达；</p><p>其次是可控制性，在出现丢包或网络状态不佳时，TCP 会按情况调整自己的行为，控制自己的发送速度或者重发。</p><p>4、面向字节流</p><p>UDP 数据传输是基于数据报，只是继承了 IP 层的特性；TCP 是基于字节流的，是为了维护状态，将IP 包变成字节流。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经（TCP 部分）</title>
      <link href="/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88TCP%20%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2022/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88TCP%20%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-和-UDP-的区别-？"><a href="#TCP-和-UDP-的区别-？" class="headerlink" title="TCP 和 UDP 的区别 ？"></a>TCP 和 UDP 的区别 ？</h2><p><img src="https://img.php.cn/upload/image/183/308/585/1605056951790214.png" alt=""></p><p>基本上来说：TCP 是面向连接的、可靠的、基于字节流的传输层协议，UDP 是面向无连接的传输层协议。</p><p>与 UDP 的区别，主要体现在几个方面：</p><p>1、连接性</p><p>所谓连接，指的是客户端和服务器端的连接，进双方通信之前，TCP是需要进行 3 次握手建立连接，UDP 没有相应建立连接的过程。</p><p>2、单播、多播、广播的功能</p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能；</p><p>TCP 仅支持单播传输，每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p>3、可靠性</p><p>TCP 的可靠性主要体现在两个方面：一是有状态，二是可控制。</p><p>首先是有状态，TCP 是会记录哪些数据已发送，哪些数据对方是否接收到，而且会保证数据按顺序送达；</p><p>其次是可控制性，在出现丢包或网络状态不佳时，TCP 会按情况调整自己的行为，控制自己的发送速度或者重发。</p><p>4、面向字节流</p><p>UDP 数据传输是基于数据报，只是继承了 IP 层的特性；TCP 是基于字节流的，是为了维护状态，将IP 包变成字节流。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 主题美化</title>
      <link href="/2022/08/29/Hexo%20%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/2022/08/29/Hexo%20%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>使用（<code>css</code>+<code>js</code>） 实现将<code>静态</code>图片绘制成动态 <code>gif</code> ，我将其应用到每个有 <code>nav</code>盒子的页面，成品效果如下：</p><h1 id="实现库洛米挂坠"><a href="#实现库洛米挂坠" class="headerlink" title="实现库洛米挂坠"></a>实现库洛米挂坠</h1><p>本文使用（css+js） 实现将静态图片绘制成动态 gif ，我将其应用到每个有 nav盒子的页面,</p><p><video src="https://live.csdn.net/v/embed/230732"  style="width: 400px; height: 300px;"></video></p><p>CSDN地址：<a href="https://editor.csdn.net/md/?articleId=126249663" target="_blank" rel="noopener">piaohuier</a></p><p>我的博客：<a href="https://blog.puhuier.xyz/" target="_blank" rel="noopener">piaohuier</a><br>详细步骤如下：</p><h2 id="找到想要的图片（注意：不是-gif-动图）"><a href="#找到想要的图片（注意：不是-gif-动图）" class="headerlink" title="找到想要的图片（注意：不是 gif 动图）"></a>找到想要的图片（注意：不是 gif 动图）</h2><p>如下，原图<code>120*130 px</code>：<br><img src="https://img-blog.csdnimg.cn/1cd104d358cf4f1185d224fb5e351a7e.png" alt="在这里插入图片描述"></p><h2 id="PS-绘制-css-图片素材"><a href="#PS-绘制-css-图片素材" class="headerlink" title="PS 绘制 css 图片素材"></a>PS 绘制 css 图片素材</h2><p><img src="https://img-blog.csdnimg.cn/fcc896daf4f94d43a506bc6b20285be9.png" alt="在这里插入图片描述"><br>复制图片，改造图片动作，绘制成几份图片。其中，4 个小图高宽相同，因此整个图是高<code>130px</code>,宽120*4=<code>480px</code></p><h2 id="引入代码设置"><a href="#引入代码设置" class="headerlink" title="引入代码设置"></a>引入代码设置</h2><p><code>img</code>:将放在主题目录下：\blog\themes\Butterfly\source\img\XXX.png<br><code>css</code>:主题目录下：\blog\themes\Butterfly\source\css\background.css<br><code>javascript</code>:主题配置文件：butterfly.yml，找到<code>inject</code>部分，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">  <span class="string">//</span> <span class="string">主题目录下的相对路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="/js/my-js/diy.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript-代码部分"><a href="#JavaScript-代码部分" class="headerlink" title="JavaScript 代码部分"></a>JavaScript 代码部分</h2><p>通过原生 JavaScript ，主要思想是使用 <code>createElement</code>方法、<code>appendChild</code> 方法和<code>className</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 是否引入</span></span><br><span class="line"><span class="comment">//  alert('')</span></span><br><span class="line"><span class="comment">// 头部大背景元素</span></span><br><span class="line"><span class="comment">// 获取每个页面共同元素 body_wrap</span></span><br><span class="line"><span class="keyword">var</span> body_wrap = <span class="built_in">document</span>.querySelector(<span class="string">'#body-wrap'</span>)</span><br><span class="line"><span class="comment">// 记录是否创建元素</span></span><br><span class="line"><span class="comment">// 是否首页</span></span><br><span class="line"><span class="comment">// 原生 jS 没有链式编程，因此分别存储</span></span><br><span class="line"><span class="keyword">var</span> navNode = body_wrap.firstElementChild</span><br><span class="line"><span class="keyword">var</span> navClassName = navNode.className</span><br><span class="line"><span class="comment">// console.log(navClassName)</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 内容块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(layoutPage.offsetTop)</span></span><br><span class="line"><span class="comment">// var topsize = bgUp.scrollTop</span></span><br><span class="line"><span class="keyword">var</span> ceilingLamp</span><br><span class="line"><span class="comment">// console.log(window.clientHeight)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.pageYOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// flag = true</span></span><br><span class="line">  <span class="comment">// var node = document.createElement("div");</span></span><br><span class="line">  <span class="comment">// var contentnode = document.createElement("img")</span></span><br><span class="line">  <span class="comment">// node.className = "ceilingLamp"</span></span><br><span class="line">  <span class="comment">// bgUp.appendChild(node)</span></span><br><span class="line">  <span class="comment">// node.appendChild(contentnode)</span></span><br><span class="line">  ceilingLampF()</span><br><span class="line">  clacHeight(ceilingLamp, flyNode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.pageYOffset)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.pageYOffset &gt;= <span class="number">0</span> &amp;&amp; flag == <span class="literal">false</span>) &#123;</span><br><span class="line">    ceilingLampF()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.pageYOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    clacHeight(ceilingLamp, flyNode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'隐藏吊灯'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  吊灯、库洛米的动态高度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clacHeight</span>(<span class="params">postNode, flyNode</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// window.pageYOffset : 是窗口被卷曲的长度</span></span><br><span class="line">  <span class="keyword">var</span> extent = <span class="built_in">window</span>.pageYOffset</span><br><span class="line">  <span class="keyword">if</span> (navClassName == <span class="string">"full_page"</span>) &#123;</span><br><span class="line">    postNode.style.height = extent - <span class="number">500</span> + <span class="string">"px"</span></span><br><span class="line">    flyNode.style.top = postNode.style.height</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    postNode.style.height = extent + <span class="string">"px"</span></span><br><span class="line">    flyNode.style.top = postNode.style.height</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ceilingLampF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> NewNode = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="keyword">var</span> contentnode = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>)</span><br><span class="line"></span><br><span class="line">  NewNode.className = <span class="string">"ceilingLamp"</span></span><br><span class="line">  navNode.appendChild(NewNode)</span><br><span class="line"></span><br><span class="line">  contentnode.className = <span class="string">"fly"</span></span><br><span class="line">  NewNode.appendChild(contentnode)</span><br><span class="line"></span><br><span class="line">  ceilingLamp = <span class="built_in">document</span>.querySelector(<span class="string">".ceilingLamp"</span>)</span><br><span class="line">  flyNode = <span class="built_in">document</span>.querySelector(<span class="string">".fly"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css-部分"><a href="#css-部分" class="headerlink" title="css 部分"></a>css 部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.ceilingLamp &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 100%;</span><br><span class="line">  right: 15vh;</span><br><span class="line">  width: 10px;</span><br><span class="line">  border: 6px dashed rgb(230, 106, 160);</span><br><span class="line">  background-color: rgb(72, 61, 78);</span><br><span class="line">  height: 0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fly &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 120px;</span><br><span class="line">  height: 130px;</span><br><span class="line">  background: url(&#x2F;img&#x2F;fly.png) no-repeat;</span><br><span class="line">  transform: translate(-50%, -35%);</span><br><span class="line">  &#x2F;* 我们元素可以添加多个动画， 用逗号分隔 *&#x2F;</span><br><span class="line">  animation: flyKuluomi 1s steps(4) infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flyKuluomi &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    background-position: 0 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  100% &#123;</span><br><span class="line">    background-position: -480px 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题美化 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机端不显示库洛米挂坠</title>
      <link href="/2022/08/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/08/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="html-标签"><a href="#html-标签" class="headerlink" title="html 标签"></a>html 标签</h1><p>开发移动端，实现理想视口效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="CSS-媒体查询"><a href="#CSS-媒体查询" class="headerlink" title="CSS 媒体查询"></a>CSS 媒体查询</h1><p>根据屏幕宽度调整样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 媒体查询窗口设置 一般宽度小于600px 代表手机端*/</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span><span class="number">600px</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.fly</span>,</span><br><span class="line">  <span class="selector-class">.ceilingLamp</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，为了解决手机端库洛米挂坠影响阅读体验，而设置手机端不显示库洛米挂坠。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案</title>
      <link href="/2022/08/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2022/08/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="PC-端"><a href="#PC-端" class="headerlink" title="PC 端"></a><strong>PC 端</strong></h2><p>360 浏览器、谷歌浏览器、火狐浏览器、QQ 浏览器、百度浏览器、搜狗浏览器、IE 浏览器。</p><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a><strong>移动端</strong></h2><p>UC 浏览器,、QQ 浏览器、欧朋浏览器、百度手机浏览器、360安全浏览器、谷歌浏览器、搜狗手机浏览器、猎豹浏览器、以及其他杂牌浏览器。</p><p>国内的 UC 和 QQ ，百度等手机浏览器都是根据<code>Webkit</code>修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于 <code>Android</code> 修改开发的一样。</p><blockquote><p>总结：兼容移动端主流浏览器，处理<code>Webkit</code>内核浏览器即可。</p></blockquote><h1 id="为什么做适配-？"><a href="#为什么做适配-？" class="headerlink" title="为什么做适配 ？"></a>为什么做适配 ？</h1><p>不同设备，会出现一下问题</p><ul><li><a href="https://www.cnblogs.com/gg-qq/p/14535413.html" target="_blank" rel="noopener">1px 问题</a></li><li>高清屏图片显示模糊</li><li>屏幕尺寸不变，分辨率翻倍，图像会被缩小一倍</li></ul><p>解决不局限于以上问题，以实现<strong>布局伸缩</strong>和<strong>内容大小固定的</strong>完美统一。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>物理像素、设备像素比（dpr）</li><li>分辨率</li><li>视口</li></ul><h2 id="像素、设备像素比（dpr）"><a href="#像素、设备像素比（dpr）" class="headerlink" title="像素、设备像素比（dpr）"></a>像素、设备像素比（dpr）</h2><p><strong>设备独立像素</strong>、<strong>CSS像素</strong>和<strong>设备像素</strong>之间有联系，又有很大的区别</p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p><strong>设备独立像素</strong>（dips）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了 <strong>CSS 像素</strong>。</p><p><strong>CSS 像素</strong>：CSS 像素是相对单位，主要在浏览器上精确度量 Web 页面上的内容，实际不存在；</p><p><strong>设备像素</strong>又称为 <strong>物理像素</strong>（dp），指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了，比如苹果 6\7\8 是<code>750 x 1334</code>。</p><h3 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h3><ul><li>像素（px）是相对于观看设备的。对于低 dpi 的设备，1px 是显示器的一个设备像素点（物理像素）。对于打印机和高分辨率屏幕，1px 表示多个设备像素。</li><li>PC 端页面，1px 等于 1 个物理像素（在100%，未缩放的情况下），但是移动端就不尽相同。</li><li>一个 px 的能显示的物理像素点的个数，称为物理像素比或屏幕像素比（dpr）。</li></ul><p><strong>设备像素比（dpr）</strong></p><p>【公式】：设备像素比 = 物理像素 / 设备独立像素</p><blockquote><p>当设备像素比为 1 时，使用 1（1×1）个设备像素显示 1 个 CSS 像素</p><p>当设备像素比为 2 时，使用 4（2×2）个设备像素显示 1 个 CSS 像素</p><p>当设备像素比为 3 时，使用 9（3×3）个设备像素显示 1 个 CSS 像素</p></blockquote><p>【获取设备像素比】：通过<code>JS</code>中对象方法， <code>window.devicePixelRatio</code></p><p>一般情况，使用的位图，每一个位图像素对应屏幕的<code>一</code>个物理像素渲染。但在高清屏中，每一个位图像素对应屏幕的<code>多</code>个物理像素渲染，位图是最小单位，不能再分，便会导致图片失真。</p><p>【移动端适配发展过程】</p><blockquote><p>移动端不适配：</p><ul><li>导致手机只能看到网页的一部分，需要翻滚才能看到其他部分</li></ul><p>增大页面载入时初始视口的宽度：</p><ul><li>页面缩小，需要通过放大和滑动来浏览细节</li><li>滚动条问题依然存在</li><li>限制了依据视口宽度做媒体查询机制的有效性</li></ul><p>根据视口宽度而改变视口，允许开发人员定制视口大小和缩放比例</p><ul><li>可以使用媒体查询做移动端适配，设置视口宽度为设备宽度：<code>viewport</code>为 <code>device-width</code>，保证媒体查询机制的有效性</li><li>结合相对单位（%、rem、vh 等）,设置合适的<code>viewport</code>，以实现<strong>布局伸缩</strong>和<strong>内容大小固定</strong>完美统一。</li></ul></blockquote><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p><strong>物理分辨率</strong>：指横、纵向上的<code>物理像素点</code>数量</p><ul><li>iPhone6 屏幕分辨率：750 * 1334 （代表：横向有 750 个像素，纵向 1334 个像素）</li></ul><p>但是，屏幕尺寸不变，分辨率翻倍，图像会被缩小一倍，因此需要办法解决。</p><p><strong>逻辑分辨率</strong>：指纵、横方向上的<code>设备独立像素点</code>数量</p><blockquote><p>如：物理分辨率为<code>750 X 1334</code>，用<code>4</code>个物理像素当一个像素使用，dpr = 2 ，则逻辑分辨率为<code>350 X 667</code></p></blockquote><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>布局视口、视觉视口、理想视口</p><p>【布局视口】ios、android 一般将此视口分辨率设置为 980px，显示效果不好，导致字体太小，用户需要手动缩放页面。</p><p>【视觉视口】viewport，用户能看到的区域，一般为<strong>设备宽</strong>。</p><p>【理想视口】布局视口 == 设备宽</p><h1 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h1><p>1、响应式设计</p><p>2、自适应设计（单独制作）</p><h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><p>常见于 <code>PC</code>、移动等多端共用一套代码的场景，比如 bootstrap 、媒体查询。</p><h2 id="单独制作（主流）"><a href="#单独制作（主流）" class="headerlink" title="单独制作（主流）"></a>单独制作（主流）</h2><p>为了在特定的设备上显示最好的视觉效果，大部分移动端产品都有了区分于 PC 的专门的 m 站。</p><p>其技术实现：服务器根据浏览器请求的 user-agent 判断设备类型，然后返回( 或重定向 )对应的站点内容。</p><ul><li>流式布局</li><li>flex 弹性布局</li><li>less + rem + 媒体查询</li><li>混合布局</li></ul><p>以下按照效果分类：</p><h3 id="布局伸缩式"><a href="#布局伸缩式" class="headerlink" title="布局伸缩式"></a><strong>布局伸缩式</strong></h3><p>常见于排版比较简单的信息流展示类业务。其布局特点一般为<strong>横向伸缩</strong>，<strong>竖向高度固定</strong>或由<strong>内容填充</strong>决定;<br>文字、图标等网页内容一般会固定大小， 且在宽屏窄屏上的视觉大小保持一致。</p><p>【<strong>技术</strong>】：</p><p>设置<code>viewport</code>宽度为<code>device-width</code>, 保证<code>px</code>为单位取值的一些文字图标等网页内容视觉上在宽窄屏大小一致。<br>【<strong>布局方案</strong>】:</p><p>灵活使用相对单位 % 或<code>flex</code> 弹性布局，以保证布局的横向伸缩和容器内各元素的大小间距符合预期。</p><h3 id="等比例缩放式"><a href="#等比例缩放式" class="headerlink" title="等比例缩放式"></a><strong>等比例缩放式</strong></h3><p>等比缩放，顾名思义整个页面根据屏幕宽度的不同进行等比缩放，常见于产品类、运营类等业务场景。</p><p>【<strong>Flexible 方案</strong>】</p><p>1、<code>rem</code> 方式模拟 <code>vw</code> 特性适配多种屏幕尺寸</p><p><code>Flexible</code>将整个页面的宽度切成了<code>10</code>份，然后将计算出来的页面宽度的<code>1/10</code>设置为<code>html</code>节点的<code>fontSize</code>,也就<br>意味着，之后我们在当前页面的<code>htmI</code>节点的子节点上应用<code>rem</code>为单位时，都是按照页面比例来计算的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> rem = doc.clientWidth / <span class="number">10</span>;</span><br><span class="line">doc.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">setRemUnit();</span><br></pre></td></tr></table></figure><p>2、控制 <code>viewport</code> 的 <code>width</code> 和 <code>scale</code>适配高倍屏显示</p><ul><li><p>宽度设置：<code>width</code>为<code>device -width</code>，改变浏览器<code>viewport</code>的默认宽度为理想视口宽度，从而使得用户可以看到完整的布局的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>等比设置：改变比例之前 <code>1px</code> 对应 多个物理像素，会导致 <code>1px</code> 变粗。通过得到设备的 dpr，设置<code>initial-scale、maximum-scale 、minimum-scale</code>的值，从而实现 1 物理像素 = 1CSS 像素，以适配高倍屏的显示效果（就是在这个地方规避了的“1px问题”）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> metaEL = doc.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line"><span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">var</span> scale = <span class="number">1</span> / dpr;</span><br><span class="line">metaEl.setAttribute(</span><br><span class="line"><span class="string">'content'</span>，</span><br><span class="line"><span class="string">'width=device-width，initial-scale='</span>+ scale + <span class="string">'，maximum-scale='</span> + scale + <span class="string">'，minimum-scale='</span>+ scale)</span><br></pre></td></tr></table></figure></li></ul><p>【<strong>使用视口单位</strong>】</p><ul><li>vw（Viewport’s width）：1vw 等于视口宽度的1%</li><li>vh（Viewport’s height） ：1vh 等于视口高度的1% </li><li>vmin：选取 vw 和 vh 中的最小值</li><li>vmax：选取 vw 和 vh 中的最大值</li></ul><h1 id="快速上手-code"><a href="#快速上手-code" class="headerlink" title="快速上手 code"></a>快速上手 code</h1><p>1、媒体查询 <code>Media Queries</code>——CSS3</p><p>2、<code>flex</code> 弹性布局</p><p>3、<code>rem</code> + <code>viewport</code> 缩放</p><p>4、<code>vw</code> / <code>vh</code> 布局</p><p>5、<code>meta</code> 理想视口</p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p><code>media queries</code> :主要通过查询不同的可视宽度来执行不同的 <code>css</code> 代码，最终以达到界面的配置。</p><p><strong>语法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span>|<span class="keyword">only</span> mediatype <span class="keyword">and</span> (expressions) &#123;</span><br><span class="line">    <span class="comment">/* CSS 代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字：and、not、only<br> （1）and：表示可以将多个媒体特性连接到一起，相当于“且”的意思<br> （2）<strong>not</strong>：表示排除某个媒体类型，相当于“非”的意思，<strong>可以省略</strong><br> （3）<strong>only</strong>：表示指定某个特定的媒体类型，<strong>可以省略</strong></p><p><code>mediatype</code>：媒体类型</p><div style="width: auto; margin:0 auto;"><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">用于所有多媒体类型设备</td></tr><tr><td align="center">print</td><td align="center">用于打印机</td></tr><tr><td align="center"><strong>screen</strong></td><td align="center"><strong>用于电脑屏幕，平板，智能手机等。</strong></td></tr><tr><td align="center">speech</td><td align="center">用于屏幕阅读器</td></tr></tbody></table></div><p><code>expressions</code>：条件表达式</p><ul><li>max-width： 输出设备中页面最大可视区域宽度，小于这个width时，其中的css生效</li><li>min-width： 输出设备中页面最小可视区域宽度，大于这个width时，其中的css生效</li><li>max-height： 输出设备中页面最大可视区域高度</li><li>min-height： 输出设备中页面最小可视区域高度</li><li>……</li></ul><p>【案例】：<strong>背景色</strong>随着<strong>可视窗口</strong>大小改变而改变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 表示 匹配媒体类型为电脑屏幕等在宽度大于480px 并且小于560px时 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">480px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">560px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>引入方式：</li></ol><ul><li><code>head</code>头部引入 <code>link</code>标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen and (max-width:600px)"</span> <span class="attr">href</span>=<span class="string">"./css/blue.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:900px)"</span> <span class="attr">href</span>=<span class="string">"./css/red.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:600px) and (max-width:900px)"</span> <span class="attr">href</span>=<span class="string">"./css/green.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>CSS</code>代码中</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">600px</span>) &#123;</span><br><span class="line">            <span class="selector-tag">body</span> &#123;</span><br><span class="line">                <span class="attribute">background-color</span>: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">900px</span>) &#123;</span><br><span class="line">            <span class="selector-tag">body</span> &#123;</span><br><span class="line">                <span class="attribute">background-color</span>: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*使用关键词"and"将多个媒体特性结合在一起*/</span></span><br><span class="line">       <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">600px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">900px</span>)&#123;</span><br><span class="line">            <span class="selector-tag">body</span> &#123;</span><br><span class="line">                <span class="attribute">background-color</span>:green;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>style 标签内 <code>@import</code> 中引入</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:600px) and (max-width:900px)"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> url(<span class="string">"css/style.css"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="flex-弹性布局"><a href="#flex-弹性布局" class="headerlink" title="flex 弹性布局"></a>flex 弹性布局</h2><p><a href="https://www.bilibili.com/video/BV1di4y1U75N?spm_id_from=333.337.top_right_bar_window_history.content.click&vd_source=97637b96c4294f5b0f10fdcfcfe59d55" target="_blank" rel="noopener">急速入门视频</a></p><p>可以控制子盒子的位置</p><p><strong>flex 弹性布局：</strong> </p><ul><li>操作方便，布局简单，移动端应用很广泛</li><li><code>PC</code>端浏览器支持情况差</li><li><code>IE11</code>或更低版本，不支持或部分支持</li></ul><p><strong>建议：</strong> </p><ol><li>若是<code>PC</code>端布局，建议传统布局。</li><li>若是移动端布局或者不考虑兼容性的<code>PC</code>端布局，还是使用<code>flex</code>弹性布局。</li></ol><p><strong>布局原理</strong>：</p><p>给父盒子添加<code>flex</code>属性，来控制子盒子的位置排列方式从而实现<code>flex</code>布局，子盒子也可以控制自己的位置。</p><ol><li>有两个坐标轴：主轴、交叉轴</li><li>三个默认属性：flex-direction、justify-content、align-items</li></ol><p><strong>父项常见属性解释</strong></p><ul><li><code>flex-direction</code>：设置主轴的方向（默认值：<code>row</code>，从左到右）</li><li><code>justify-content</code>：设置<strong>子元素</strong>在主轴上的排列方式（默认值：<code>flex-start</code>，从起点开始排列）</li><li><code>align-items</code>：设置子元素在交叉轴上的位置（默认值：<code>stretch</code> ，占满拉伸）（单行）</li></ul><p><strong>子项常见属性</strong></p><ul><li>flex：子项目占的份数</li><li>align-self：控制子项自己在侧轴的排列方式</li><li>order：属性定义子项的排列顺序（前后顺序）</li></ul><h2 id="rem-viewport-缩放"><a href="#rem-viewport-缩放" class="headerlink" title="rem + viewport 缩放"></a>rem + viewport 缩放</h2><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p><code>rem</code>是<strong>CSS3</strong>新增的一个相对单位，其值是相对于<strong>html</strong>根元素的，<code>html</code>的<code>font-size</code>设置多大，<code>1rem</code>就是多大；</p><p>比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size </span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，1em = 30px；则非根元素设置 <code>width:2rem;</code>时，其表示就是<code>24px</code>。</p><p><strong>rem 的优势</strong>：整个页面中只有一个<html>，可以很好的来控制整个页面的元素大小比例。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 移动适配 </span></span><br><span class="line"><span class="comment"> 1. HTML 标签加字号 1/10;</span></span><br><span class="line"><span class="comment"> 2. 写 rem 单位的尺寸 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">width:</span><span class="number">375px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">37.5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">41.4px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="comment">/* 68 * 29 */</span></span><br><span class="line">    <span class="comment">/* width: 68px; */</span></span><br><span class="line">    <span class="comment">/* 设计稿375, HTML 37.5   68/37.5 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.813rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0.773rem</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，通过媒体查询可视窗口大小来直接调整<code>html</code>字号大小，间接调整<code>rem</code> 表示的字号大小，达到缩放视口，字体响应式缩放的目的。</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>学习 <code>viewport</code>就要先认识三种<a href="https://blog.csdn.net/puhuihui/article/details/123966446" target="_blank" rel="noopener">视口</a>，和 <code>dpr</code>。</p><p>dpr </p><p>将布局视口适配为视觉视口，即<strong>理想视口</strong>，一个标准的移动<code>web</code>页面 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1，user-scalable=0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了兼容不同设备的不同 <code>dpr</code>值，使用<code>js</code>动态设置 <code>initial-scale</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var oMeta &#x3D; document.createElement(&#39;meta&#39;);</span><br><span class="line">oMeta.setAttribute(&#39;name&#39;,&#39;viewport&#39;);</span><br><span class="line">if (window.devicePixelRatio &#x3D;&#x3D; 3) &#123;</span><br><span class="line">    oMeta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width, initial-scale&#x3D;0.333,minimun-scale&#x3D;0.333,maximun-scale&#x3D;0.333,user-scalable&#x3D;no&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (window.devicePixelRatio &#x3D;&#x3D; 2) &#123;</span><br><span class="line">    oMeta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width, initial-scale&#x3D;0.5,minimun-scale&#x3D;0.5,maximun-scale&#x3D;0.5,user-scalable&#x3D;no&#39;);</span><br><span class="line">&#125;</span><br><span class="line">document.getElementsByTagName(&#39;head&#39;)[0].appendChild(oMeta);</span><br></pre></td></tr></table></figure><p>根据屏幕宽度设定<code>rem</code>值，需要适配的元素都使用<code>rem</code>单位，不需要适配的元素还是使用<code>px</code>单位。<code>1em=16px</code> ;</p><blockquote><p>根据rem将页面放大dpr倍, 然后viewport设置为1/dpr.</p></blockquote><h2 id="vw-vh-布局"><a href="#vw-vh-布局" class="headerlink" title="vw / vh 布局"></a>vw / vh 布局</h2><p>视口单位：<code>vW</code>和<code>vh</code>分别指的是屏幕可视窗口的宽、高。</p><p><strong>使用方法</strong></p><p><code>1vw</code> 或<code>1vh</code>，前面的数值代表占屏幕宽、高的百分比 <code>%</code>；</p><p>如<code>20vw</code>代表占屏幕宽度的20%；</p><p>不用设置 html 具体数值，用起来更方便。</p><h2 id="meta-理想视口"><a href="#meta-理想视口" class="headerlink" title="meta 理想视口"></a>meta 理想视口</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>width :</strong> 控制<code>viewport</code>的大小，可以指定一个具体的值，如600， 或者特殊的值，如<code>device-width</code>为设备的宽度</p></li><li><p><strong>initial-scale :</strong> 初始缩放比例，页面第一次加载时的缩放比例，范围从0到10.0</p></li><li><p><strong>maximum-scale :</strong> 允许用户缩放到的最大比例，范围从0到10.0</p></li><li><p><strong>minimum-scale :</strong> 允许用户缩放到的最小比例，范围从0到10.0</p></li><li><p><strong>user-scalable :</strong> 用户是否可以手动缩放，值可以是：① yes：允许用户缩放；② no：不允许用户缩放</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（第二章内容）</title>
      <link href="/2022/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/"/>
      <url>/2022/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><center>网络协议</h2><p>计算机网络的所有通信过程必须遵守某种、些规则——<strong>协议</strong></p><p>网络协议：简称<strong>协议</strong>，是为进行网络中的数据交换而建立的规则、标准和约定。</p><p>协议规定了交换消息的<code>格式、意义、顺序、</code>以及<code>动作</code></p><ol><li><p>协议的三要素</p><p>语法（Syntax）：数据与控制信息的结构和格式</p><p>语义（Semantics）：需要发出何种控制信息、需要完成的动作以及做何种响应、差错控制；</p><p>时序（Timing）：时间顺序、速度匹配</p></li></ol><p>协议规范了网络种所有信息发送和接收过程。</p><p>[ 资源共享 ]：是计算机网络的功能，资源包括计算机硬件资源和软件资源。</p><p>[ 计算机网络的主要功能 ]：资源共享（基础）、 信息交换 、分布式处理 、集中管理。</p><p>[ 计算机网络的分类 ]：</p><p>1、根据<code>规模大小</code>、<code>距离远近</code>分类：局域网（LAN）、城域网（MAN）、广域网（WAN）。</p><p>2、根据网络<code>操作系统</code>分类： NIX 网络、NOVELL 网络、Windows NT 网络。</p><p>3、 根据<code>信息传输技术</code>分类：广播式网络、点到点网络。</p><p>4、根据<code>连接方式</code>分类：总线型、星型、环型、树型和混合型等。</p><p>[ 计算机网络的基本组成 ]：网络操作系统、网络适配器（网卡）、网络电缆（网络线）、服务器和工作站等。</p><h1 id="网络应用的基础"><a href="#网络应用的基础" class="headerlink" title="网络应用的基础"></a><center>网络应用的基础</h1><h2 id="几种体系结构-？"><a href="#几种体系结构-？" class="headerlink" title="几种体系结构 ？"></a><center>几种体系结构 ？</h2><h3 id="客户机-服务器结构（Client-Server，C-S）"><a href="#客户机-服务器结构（Client-Server，C-S）" class="headerlink" title="客户机/服务器结构（Client-Server，C/S）"></a>客户机/服务器结构（Client-Server，C/S）</h3><p>服务器和客户端通讯，比如 <code>web</code></p><h3 id="点对点结构（Peer-to-peer，P2P）"><a href="#点对点结构（Peer-to-peer，P2P）" class="headerlink" title="点对点结构（Peer-to-peer，P2P）"></a>点对点结构（Peer-to-peer，P2P）</h3><p>客户端之间通讯</p><p>相对于<code>C/S</code>存在的优缺点</p><blockquote><p>优点：高度可伸缩</p><p>缺点：难于管理</p></blockquote><h3 id="混合结构（Hybrid）"><a href="#混合结构（Hybrid）" class="headerlink" title="混合结构（Hybrid）"></a>混合结构（Hybrid）</h3><p>将<code>C/S</code>和<code>P2P</code>混合使用</p><p>文件传输使用：<code>P2P</code></p><p>文件搜索使用：<code>C/S</code>——集中式</p><h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a><center>进程间的通信</h2><p>进程是什么  ？</p><ul><li>主机上运行的程序</li></ul><p>同一主机上运行的进程间如何通信 ？</p><ul><li>进程间的通信机制</li><li>操作系统提供</li></ul><p>不同主机上运行的进程间如何通信 ？</p><ul><li>消息交换</li></ul><p>客户端进程：发起通讯的进程</p><p>服务器进程：等待通信请求的进程</p><blockquote><p>Q：采用<code>P2P</code>架构的应用是否存在客户机进程、服务器进程之分？</p><p>A：存在！</p></blockquote><h3 id="套接字：Socket"><a href="#套接字：Socket" class="headerlink" title="套接字：Socket"></a>套接字：Socket</h3><p>进程之间通信利用<code>socket</code>发送/接收消息实现 </p><p>传输基础设施向进程提供 <code>API</code></p><ul><li>传输协议的选择</li><li>参数的设置</li></ul><p>网络应用的开发通常叫：<code>socket</code>编程</p><h4 id="如何寻址进程-？"><a href="#如何寻址进程-？" class="headerlink" title="如何寻址进程 ？"></a>如何寻址进程 ？</h4><p>不同主机上进程间的通信，那么每个进程必须拥有<code>标识符</code></p><p>如何寻址主机？——主机</p><blockquote><p>Q：有了<code>IP</code>地址后，是否足以定位进程？</p><p>A：no，同一主机可能同时多个进程需要通信</p></blockquote><p>端口号/Port number</p><p>为每个主机上需要通信的进程分配一个端口号</p><p>进程的标识符</p><p><code>IP</code>地址+端口号</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a><center>应用层协议</h3><p>网络应用组遵循应用层协议</p><p>公开协议</p><ul><li><p>由<code>RFC</code> 定义</p></li><li><p>允许互操作</p></li><li><p>HTTP、SMTP、……</p></li></ul><p>私有协议</p><p>多数<code>P2P</code>文件共享应用</p><p>应用层协议的内容</p><p>消息的类型</p><ul><li>请求消息</li><li>响应消息</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（第一章内容）</title>
      <link href="/2022/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"/>
      <url>/2022/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><center>计算机网络</h1><p>计算机网络指利用<code>通信设备</code>和<code>线路</code>将地理位置不同的功能、多个计算机系统互联起来，以功能完善的网络软件实现网络中资源共享和信息交换的系统。</p><blockquote><p>定义：计算机网络就是<code>互连</code>的、<code>自治</code>的计算机集合。</p><p>自治：无主从关系</p><p>互连：互联互通</p><ul><li>通信链路</li></ul></blockquote><p>Q：距离远、数量大怎么保证互连？</p><p>A：通过<code>交换网络</code>互联主机（交换节点：路由器、交换机）</p><h2 id="什么是Internet？（组成细节角度）"><a href="#什么是Internet？（组成细节角度）" class="headerlink" title="什么是Internet？（组成细节角度）"></a>什么是<code>Internet</code>？（组成细节角度）</h2><p>【全球最大的<code>互联网络</code>】</p><ul><li><p>ISP（Internet Service Provide）网路互联的<strong>网络之网络</strong></p><p>计算设备：主机 = 端系统 ，运行各种网络应用</p><p>PC　服务器　笔记本　智能手机</p></li></ul><p>【连接方式】</p><ul><li><p><code>通信链路</code></p><p>光纤、铜缆、无线电、卫星 ……</p></li><li><p>分组交换</p><p>转发分组（数据包）</p><p><strong>路由器</strong>（routers）和 <strong>交换机</strong>（switches）</p></li></ul><h2 id="什么是Internet？（服务角度）"><a href="#什么是Internet？（服务角度）" class="headerlink" title="什么是Internet？（服务角度）"></a>什么是<code>Internet</code>？（服务角度）</h2><ul><li><p>为网络应用提供通信服务的通信基础设施</p><p>Web、Email、网络游戏、电子商务……</p></li><li><p>为网络应用提供应用编程接口（<code>API</code>）</p><p>支持应用程序’’连接’’<code>Internet</code>发送 / 接收数据</p></li></ul><h1 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a><center>计算机网络结构</h1><p>【网络边缘】：</p><p>1、主机    2、网络应用</p><p>接入网络，物理介质：</p><p>有线或无线通信链路</p><p>【网络核心（核心网络）】：</p><p>1、互联的路由器（或分组转发设备）2、网络之网络</p><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>【主机（端系统）】：位于”<strong>网络边缘</strong>“，运行网络应用程序：web、Email</p><p>【客户/服务器（client/server）应用模型】：客户发送请求，接收服务器响应</p><p>【Peer-peer（P2P）对等的应用模型】：通信<strong>对等</strong>的应用中进行：QQ</p><p>Q：如何将网络边缘接入核心网（边缘路由器）？</p><p>A：接入网络：住宅；学校、企业；移动接入网络</p><blockquote><p> 用户最关心的是？</p><ul><li><p>带宽（bandwidth）（bps）?</p></li><li><p>共享还是独占？</p></li></ul></blockquote><h2 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h2><ol><li>数字用户线路（DSL）</li></ol><p>利用<strong>已有的</strong>电话线连接到中心局的<code>DSLAM</code></p><p>【<code>FDM</code>】根据 不同<code>HZ</code>分为：上行、下行、传统通话</p><ol start="2"><li>机构（企业）接入网络（Ethernet）</li></ol><p>– 主要用于：学校、公司等组织机构</p><p>– 传输速率：10Mbps、100Mbps、1Gbps、10Gbps</p><p>– 目前，端系统通常直接连接以太网交换机（<code>switch</code>）</p><ol start="3"><li>电缆网络</li></ol><p><code>cable modem</code></p><p>频分多路复用：在不同频带（载波）上传输不同频道</p><p>【<code>HFC</code>】混合光纤同轴电缆</p><p>– 非对称：下行高达<code>30Mbps</code>，上行<code>2Mbps</code>传输速率</p><p>– 各家庭设备通过：电缆网络 -&gt;光纤接入<code>ISP</code>路由器</p><p>– 即使<strong>带宽大</strong>、是<strong>共享</strong>的网络也会很慢</p><ol start="4"><li>无线接入网络</li></ol><p>通过<strong>共享</strong>的无线接入网络连接端系统与路由器</p><p>通过<code>基站</code>（base station）或称为”<code>接入点</code>“</p><ul><li><p>无线局域网（LANs）</p><p>同一建筑物内（30m）</p></li><li><p>广域无线接入</p><p>通过电信运营商（蜂窝网），接入范围在几十公里</p><p>带宽：1Mbps、10Mbps、100Mbps</p><p>3G、4G、5G 网</p></li></ul><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>互联的路由器网络</p><p>【关键功能】：<strong>路由</strong> + <strong>转发</strong></p><p>【路由】：确定分组从源到目的的传输路径</p><p><code>路由算法</code></p><p>【转发】：将分组从路由器的输入端口交换至正确的输出端口</p><p><code>本地转发表</code></p><p>路由表是路由器遵循路由协议，路由协议通过路由算法计算获得。</p><blockquote><p>网络核心解决的基本问题：</p><p>Q：如何实现数据从源主机通过网络核心送达目的主机？</p><p>A：数据交换</p></blockquote><h3 id="Internet结构：网络之网络"><a href="#Internet结构：网络之网络" class="headerlink" title="Internet结构：网络之网络"></a>Internet结构：网络之网络</h3><p>端系统通过<code>接入ISP</code>连接到<code>Internet</code></p><blockquote><p>Q：当前的<code>Internet</code>结构 ？</p><p>A：无人能给出精确的描述</p></blockquote><h1 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a><center>数据交换</h1><p>– 动态转接、动态分配传输资源</p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>【三个阶段】电路建立连接-通信-释放连接</p><p>【特点】独占资源</p><blockquote><p>Q：电路交换网络如何共享中继线 ？</p><p>A：多路复用技术</p></blockquote><p>【多路复用技术】</p><p>– 链路、网络资源（如带宽）划分为<strong>资源片</strong>，将资源片分配给各路呼叫（calls），每路呼叫<code>独占</code>分配到的资源篇进行通信，资源片可能<code>闲置</code>（无共享状态）</p><p>– 典型方法：频分多路复用（FDM）、时分多路复用（TDM）、波分多路复用（BDM）、码分多路复用（CDM）</p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>【交换方式】：存储-转发</p><p>【报文】：源（应用）发送信息整体。比如：一个文件</p><p>【传输延迟】：</p><p>– 分组传输延迟（时延）公式：<code>M/R</code>（报文长度<code>M</code>，在传输速率为<code>R</code>的链路上传输分组）</p><p>– 每次传输需要<code>M/R</code>秒</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>广泛使用</p><p>【交换方式】：存储-转发</p><p>【分组】：报文分拆出来的一系列相对较小的数据包</p><p>– 分组 = 头 + 数据</p><p>– 分组交换需要报文的<code>拆分</code>与<code>重组</code></p><p>– 会产生<code>额外开销</code></p><p>【多路复用】：分组交换——统计多路复用</p><p>【传输延迟】：</p><p>– 分组传输延迟（时延）<strong>公式</strong>：<code>L/R</code>（拆分为较小长度<code>L</code>，在传输速率为<code>R</code>的链路上传输分组）</p><p>– 每个分组传输需要<code>L/R</code>秒</p><p>链路数 ≈ 跳步数(h) = 传输链路上的路由器数(n) + 1</p><p>【交付时间】：<strong>公式</strong>：T = M / R+(h-1) L/R =  M / R+n*L/R （传输时间 + 转发时间）</p><blockquote><p>【与<strong>报文</strong>交换的区别】：</p><p><strong>报文</strong>交换使用完整的报文进行”存储-转发“；</p><p><strong>分组</strong>交换使用较小的分组进行”存储-转发“。</p><p>Q：哪种交换更好呢 ？</p><p>A：从时间效率角度、缓存角度</p><p>【传输时延】：报文交换串行，分组交换可以并行交换，后者传输效率更高。</p><p>【缓存】：分组后的数据长度小，对硬件的缓存容量要求低</p></blockquote><blockquote><p>【与<strong>电路</strong>交换的区别】：</p><p><strong>电路</strong>交换用户独占</p><p><strong>分组</strong>交换允许更过用户使用网络——网络资源充分共享</p><p>Q：分组交换绝对优于电路交换 ？</p><p>A：分组更适用于<strong>突发</strong>数据传输网络（Internet），不需要预约、占用，可能会产生拥塞，需要协议处理可靠数据传输和拥塞控制</p></blockquote><h1 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a><center>计算机网络性能</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a><strong>速率</strong></h2><p>即 <strong>数据率</strong> 或称为 <strong>数据传输速率</strong> 或 <strong>比特率</strong></p><p>– 单位时间（秒）传输信息（比特）量</p><p>– 单位 ：b/s(或<code>bps</code>)、kb/s、Gb/s</p><p>– <code>k=10^3</code>、<code>M=10^6</code>、<code>G=10^9</code></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a><strong>带宽</strong></h2><p>有两种含义，可以通过 <strong>单位</strong>、<strong>上下文</strong> </p><p>– 通信：原指信号具有的频率宽度，即最高频率与最低频率之差，单位：<code>HZ</code></p><p>– 网络中：数字信道所能传输的 <strong>最高数据率</strong>，单位：<code>b/s（bps）</code></p><h2 id="延迟-时延"><a href="#延迟-时延" class="headerlink" title="延迟/时延"></a><strong>延迟/时延</strong></h2><p>Q：分组交换为什么会发生丢包和时延 ？</p><p>A：分组在路由器缓存中排队，如果缓存满了，刚到达的分组被 <strong>丢弃</strong></p><p>【<strong>四种 分组延迟</strong>】</p><p>– 结点处理延迟：差错检验……</p><p>– 排队延迟：等待输出链路可用，取决于路由器拥塞状态，不确定</p><p>– 传输延迟：分组长度<code>L</code>（bits），链路带宽<code>R</code>（bps），<code>L/R</code></p><p>– 传播延迟：链路长度<code>d</code>、信号传播速度<code>s</code>（光速、无线电波），即公式： d/s</p><p><img src="https://img-blog.csdn.net/20180102141124840" alt=""></p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>【公式】：时延带宽积 = 传播时延 * 带宽</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201901%2F20190113010550758902.png&refer=http%3A%2F%2Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663659488&t=9ce8d8f2b74293e3b087dfc5f878a383" alt=""></p><p>链路的时延带宽积又称为：<code>以比特为单位的链路长度</code></p><h2 id="分组丢失（丢包）"><a href="#分组丢失（丢包）" class="headerlink" title="分组丢失（丢包）"></a>分组丢失（丢包）</h2><p>丢包是因为队列缓存容量有限</p><p>网络处理方式不一样，<code>Internet</code>丢失直接不要</p><p>丢包率 = 丢包数 / 已发分组总数</p><h2 id="吞吐量-率"><a href="#吞吐量-率" class="headerlink" title="吞吐量/率"></a>吞吐量/率</h2><p>表示在<strong>发送</strong>端与<strong>接收</strong>端之间传送数据速率（b/s）</p><p><strong>即时吞吐量</strong>：给定时刻的速率</p><p><strong>平均吞吐量</strong>：一段时间的平均速率</p><p>吞吐量取决于<code>瓶颈链路</code>，即端到端路劲上，限制端到端吞吐量的链路</p><h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h1><p>组成部分：主机、路由器、各种链路、应用、协议、硬件，软件……</p><p>【网络体系结构】：从<strong>功能上</strong>描述计算机网络结构</p><p>【计算机网络体系结构】：计算机网络的各层及其协议的集合</p><p>【模块化分层】：有利于系统更新、维护。有利于标准化</p><h2 id="分层网络体系结构"><a href="#分层网络体系结构" class="headerlink" title="分层网络体系结构"></a>分层网络体系结构</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.likecs.com%2Fdefault%2Findex%2Fimg%3Fu%3DaHR0cHM6Ly9waWFuc2hlbi5jb20vaW1hZ2VzLzQ4OC84NmI1ODZmNzcyMjUzZmM3YTA3NzVkZmEzZDliZjZmMC5wbmc%3D&refer=http%3A%2F%2Fwww.likecs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663662434&t=68d9c87096c06843aaf69e3134bcd8f7" alt=""></p><p>【实体】：表示任何可发送或接收信息的硬件或软件进程</p><p>任一层实体需要使用<code>下层</code>服务，遵循<code>本层</code>协议，实现本层功能，向<code>上层</code>提供服务，服务是”<code>垂直的</code>“</p><p>【协议】：控制<code>两个对等实体</code>进行通信的规则集合，协议是”<code>水平的</code>“</p><h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a><center>OSI 参考模型</h1><h2 id="OSI-参考模型解释与通信过程"><a href="#OSI-参考模型解释与通信过程" class="headerlink" title="OSI 参考模型解释与通信过程"></a>OSI 参考模型解释与通信过程</h2><p>【目的】支持<code>异构网络系统</code>的互联互通</p><p>– 异构网络系统互连的<code>国际标准</code></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F658%2Fc4aada8382de26e90247702902faf8c2.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663663065&t=b56eb6d3566e65c1b57ba28794eb7644" alt=""></p><p>注意：虚线、实线</p><p>相邻层之间通过<code>接口</code>传输数据，下面三层是<code>非端到端层</code></p><h2 id="OSI-参考模型数据封装与通信过程"><a href="#OSI-参考模型数据封装与通信过程" class="headerlink" title="OSI 参考模型数据封装与通信过程"></a>OSI 参考模型<strong>数据封装</strong>与通信过程</h2><p>一层层封装、一层层解封</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zyiz.net%2Fupload%2F202006%2F14%2F202006141726062159.png&refer=http%3A%2F%2Fwww.zyiz.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663663616&t=c8e5518aa7609b6378d668760fd9265a" alt=""></p><p>Q：为什么需要数据封装 ？</p><p>A：增加<code>控制信息</code></p><p>【<strong>控制信息</strong>】：地址、差错检测编码、协议控制</p><p>物理层</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array 原生方法</title>
      <link href="/2022/08/13/Array%20%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/"/>
      <url>/2022/08/13/Array%20%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a>Array.prototype.fill()</h1><p><strong><code>fill()</code></strong> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><h2 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">5</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array [1, 1, 0, 0, 1]</span></span><br><span class="line"><span class="comment">// Array [1, 5, 5, 5, 5]</span></span><br><span class="line"><span class="comment">// Array [6, 6, 6, 6, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">4</span>);                </span><br><span class="line"><span class="comment">// [4, 4, 4]</span></span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fill(value)</span><br><span class="line">fill(value, start)</span><br><span class="line">fill(value, start, end)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p><code>value</code></p><p>用来填充数组元素的值。</p></li><li><p><code>start</code> 可选</p><p>起始索引，默认值为 0。</p></li><li><p><code>end</code> 可选</p><p>终止索引，默认值为 <code>arr.length</code>。</p></li></ul><p><strong>返回值</strong></p><p>修改后的数组。</p>]]></content>
      
      
      <categories>
          
          <category> array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 取整、取余的方法</title>
      <link href="/2022/08/13/js%20%E5%8F%96%E6%95%B4%E3%80%81%E5%8F%96%E4%BD%99/"/>
      <url>/2022/08/13/js%20%E5%8F%96%E6%95%B4%E3%80%81%E5%8F%96%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<h1 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h1><ol><li>取整</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 丢弃小数部分，保留整数部分</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">5</span>/<span class="number">2</span>)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>向上取整</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有小数，+1</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">5</span>/<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">-5</span>/<span class="number">2</span>) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>向下取整</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有小数，-1</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">5</span>/<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-5</span>/<span class="number">2</span>) <span class="comment">// -3</span></span><br></pre></td></tr></table></figure><ol start="4"><li>四舍五入</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">5</span>/<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span> % <span class="number">4</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端、后端请求响应案例</title>
      <link href="/2022/08/11/Express/"/>
      <url>/2022/08/11/Express/</url>
      
        <content type="html"><![CDATA[<p>本文分为：前端、后端两部分讲诉。以下是前端发送请求到服务器，服务器响应前端，的整个过程的图解：</p><p><img src="https://img-blog.csdnimg.cn/14a0f3943229414b9a39cab4c3feac70.png#pic_center" alt="server"></p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>前端主要是发起请求，本文使用自定义的<code>axios</code>请求方法，分为<strong>注册页面模块</strong>、<strong>axios 请求方法模块</strong>两部分。</p><p>前端运行地址： <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><h2 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h2><p>该页面主要是通过点击提交按钮，触发点击事件，发起注册请求。</p><p>目标端口是：<a href="http://localhost:3000/api/login，协议、域名、端口号之中，存在端口号与前端运行地址不一样，满足跨域请求的条件。后端部分会讲到：如何解决跨域问题。" target="_blank" rel="noopener">http://localhost:3000/api/login，协议、域名、端口号之中，存在端口号与前端运行地址不一样，满足跨域请求的条件。后端部分会讲到：如何解决跨域问题。</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"submitForm('loginForm')"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击提交，触发并传递给<code>submitForm</code>方法参数<code>loginForm</code>。其中，<code>loginForm</code>数据形式是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loginForm:&#123;</span><br><span class="line">    username:<span class="string">""</span>,  </span><br><span class="line">    pass:<span class="string">""</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 7 行，<code>submitForm</code>发起请求，调用自定义的<code>axios</code>方法：<code>api.login(){}</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">"@/api"</span></span><br><span class="line"></span><br><span class="line">submitForm(formName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs[formName].validate(<span class="function">(<span class="params">valid</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.currentIndex===<span class="string">'login'</span>)&#123;</span><br><span class="line">                api.login(<span class="keyword">this</span>.loginForm).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 用户登陆成功</span></span><br><span class="line">                    <span class="keyword">if</span>(res.data.status === <span class="number">200</span>)&#123;</span><br><span class="line">                        <span class="comment">//用户信息存储到 vuex 和 localstorage</span></span><br><span class="line">                        <span class="keyword">this</span>.setUser(res.data)</span><br><span class="line">                        localStorage.setItem(<span class="string">'hp'</span>,<span class="built_in">JSON</span>.stringify(res.data))</span><br><span class="line">                        <span class="keyword">this</span>.$notify(&#123;</span><br><span class="line">                            title: <span class="string">'登录成功'</span>,</span><br><span class="line">                            type: <span class="string">'success'</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="comment">// 用户登陆成功跳转到home页面</span></span><br><span class="line">                        <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">this</span>.$notify.error(&#123;</span><br><span class="line">                            title: <span class="string">'登录失败'</span>,</span><br><span class="line">                            message: <span class="string">'请重新登录'</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.currentIndex===<span class="string">'register'</span>)&#123;</span><br><span class="line">                api.register(<span class="keyword">this</span>.registerForm).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(res)</span><br><span class="line">                    <span class="keyword">if</span>(res.data.status === <span class="number">200</span>)&#123;</span><br><span class="line">                        <span class="keyword">this</span>.$notify(&#123;</span><br><span class="line">                            title: <span class="string">'注册成功'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            type: <span class="string">'success'</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="axios-请求方法"><a href="#axios-请求方法" class="headerlink" title="axios 请求方法"></a>axios 请求方法</h2><p>为了请求方法的应用性更强，选择自定义请求的方式编写封装请求。</p><p>考虑到模块开发、代码可读性的好处，将请求方法封装模块分为<strong>路径配置</strong>、<strong>自定义 axios</strong>、<strong>API封装</strong>三部分。</p><h3 id="URL-路径配置"><a href="#URL-路径配置" class="headerlink" title="URL 路径配置"></a>URL 路径配置</h3><p>每次请求都使用以下预定义的路径，该文件向外导出<code>base</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = &#123;</span><br><span class="line">  baseUrl: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">  register: <span class="string">"/api/register"</span>,<span class="comment">//用户的接口</span></span><br><span class="line">  login: <span class="string">"/api/login"</span>,</span><br><span class="line">  selectTbItemAllByPage: <span class="string">'/api/backend/item/selectTbItemAllByPage'</span>,<span class="comment">//商品列表请求路径</span></span><br><span class="line">  total: <span class="string">"/api/total"</span>,<span class="comment">//商品总条数</span></span><br><span class="line">  search: <span class="string">"/api/search"</span> <span class="comment">//商品 模糊查询</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> base</span><br></pre></td></tr></table></figure><h3 id="自定义-axios"><a href="#自定义-axios" class="headerlink" title="自定义 axios"></a>自定义 axios</h3><p>自定义<code>axios</code> 易用、简洁且高效的<code>http</code>库，对发起的<code>axios</code>请求和响应进行拦截 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /api/utils/request.js 文件</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios</span></span><br><span class="line"><span class="string">// 引入qs模块，用来序列化post类型的数据</span></span><br><span class="line"><span class="string">import qs from 'qs'</span></span><br><span class="line"><span class="string">import router from "</span>@/router<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//主要步骤：三步</span></span><br><span class="line"><span class="string">// 1.创建一个axios实例</span></span><br><span class="line"><span class="string">// 2.拦截器--请求拦截</span></span><br><span class="line"><span class="string">// 3.拦截器--响应拦截</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 1.创建一个axios实例</span></span><br><span class="line"><span class="string">const instance = axios.create(&#123;</span></span><br><span class="line"><span class="string">    timeout: 5000,  //超时处理，超过时间告诉用户超时</span></span><br><span class="line"><span class="string">    // baseURL: "</span>http:<span class="comment">//localhost:3000",</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.all = axios.all;</span><br><span class="line">instance.spread = axios.spread</span><br><span class="line"><span class="comment">// 设置post的请求头</span></span><br><span class="line">instance.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line"><span class="comment">// interceptors 拦截器</span></span><br><span class="line"><span class="comment">// 2.请求拦截 做一个逻辑后再把请求发送，可以用于配置公用的逻辑，就不用每个请求都配一遍。</span></span><br><span class="line"></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">    <span class="comment">// 请求拦截配置  </span></span><br><span class="line">    <span class="comment">// 拦截成功，返回非promise实例对象config</span></span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.method === <span class="string">'post'</span>) &#123;</span><br><span class="line">            config.data = qs.stringify(config.data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断token是否存在，存在就添加到请求头上</span></span><br><span class="line">        <span class="comment">// const token = store.state.loginModule.user.token;</span></span><br><span class="line">        <span class="comment">// if(token)&#123;</span></span><br><span class="line">        <span class="comment">//     config.headers.authorization = store.state.loginModule.user.token;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截失败时，返回promise</span></span><br><span class="line">    error =&gt; <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(<span class="string">"/login"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// errorHandle打印失败状态码对应的 描述和路由去向</span></span><br><span class="line"><span class="keyword">const</span> errorHandle = <span class="function">(<span class="params">status, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"服务器收到客户端通过PUT或者POST请求提交的表示，表示的格式正确，但服务器不懂它什么意思"</span>);</span><br><span class="line">            toLogin();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书"</span>);</span><br><span class="line">            toLogin();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"客户端请求的结构正确，但是服务器不想处理它"</span>);</span><br><span class="line">            toLogin();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"资源被围定义(网络请求地址错误)"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"执行请求处理代码时遇到了异常，它们就发送此响应代码"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.interceptors拦截器配置response响应拦截</span></span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">    <span class="comment">// 成功时</span></span><br><span class="line">    response =&gt; response.status === <span class="number">200</span> ? <span class="built_in">Promise</span>.resolve(response) : <span class="built_in">Promise</span>.reject(response),</span><br><span class="line">    <span class="comment">// 失败时</span></span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; response &#125; = error;</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">            errorHandle(response.status, response.data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"请求被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 封装get请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        instance.get(url, params).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求回调成功</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'封装这里，'</span>, params)</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err.data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装post请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        instance.post(url, params).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求回调成功</span></span><br><span class="line">            resolve(res.data)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><h3 id="方法封装"><a href="#方法封装" class="headerlink" title="方法封装"></a>方法封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api/index.js 文件</span></span><br><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="comment">// 导入自定义ajax封装库axios: myaxios </span></span><br><span class="line"><span class="keyword">import</span> myaxios <span class="keyword">from</span> <span class="string">"@/api/utils/request"</span></span><br><span class="line"><span class="comment">// 导入自定义路径配置，模块化开发 简化url </span></span><br><span class="line"><span class="keyword">import</span> base <span class="keyword">from</span> <span class="string">"./base"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义前端的发送请求方法 </span></span><br><span class="line"><span class="keyword">const</span> api = &#123;</span><br><span class="line">  <span class="comment">// 注册请求</span></span><br><span class="line">  register(params) &#123;</span><br><span class="line">    <span class="comment">// 调用自定义asiox（myaxios）封装的post方法</span></span><br><span class="line">    <span class="keyword">return</span> myaxios.post(base.baseUrl + base.register, params)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义的请求方法全部导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api;</span><br></pre></td></tr></table></figure><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><p>本文采用：<code>node.js</code> + <code>express</code>+<code>MySQL</code>，创建<code>web</code> 服务器，构建后端。后端编写分为<strong>服务器模块</strong>、<strong>接口模块</strong>、<strong>连接数据库模块</strong>三部分，都是<code>server</code>文件夹下的 js 文件。</p><p>后端运行地址：<a href="http://127.0.0.1:3000/" target="_blank" rel="noopener">http://127.0.0.1:3000/</a></p><h2 id="创建服务器模块"><a href="#创建服务器模块" class="headerlink" title="创建服务器模块"></a>创建服务器模块</h2><p>因此，需要完成获取数据请求必须解决跨域问题，跨域问题可以在前端或者后端解决。本文采取后端解决，使用 <code>CORS</code>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源安全策略</a> 默认阻止“跨域”获取资源。但是 <code>CORS</code> 给了 <code>web</code> 服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口服务器 server/index.js文件</span></span><br><span class="line"><span class="comment">// 1.导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="comment">//跨域请求处理 后台处理</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">"cors"</span>)</span><br><span class="line"><span class="comment">//post传参问题</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">"body-parser"</span>)</span><br><span class="line"><span class="comment">// 导入自定义路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册中间件</span></span><br><span class="line">app.use(cors());</span><br><span class="line"><span class="comment">// app.use(express.json());</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"><span class="comment">//路由访问前缀</span></span><br><span class="line">app.use(<span class="string">'/api'</span>, router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.启动服务器</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'express server running at http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中，<code>web</code>服务器服务器对象 <code>app</code>，通过导入接口方法模块，并使用<code>app.use(&#39;/api&#39;, router)</code>实现接口方法应用。</p><h2 id="接口方法模块"><a href="#接口方法模块" class="headerlink" title="接口方法模块"></a>接口方法模块</h2><p>注册的步骤：主要是实现服务器获取请求体的数据，然后将数据插入数据库，最后给客户端响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/router.js文件</span></span><br><span class="line"><span class="comment">// 设置路由，定义对应post，URL的处理函数</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="comment">//导入数据库配置对象</span></span><br><span class="line"><span class="keyword">const</span> sqlClient = <span class="built_in">require</span>(<span class="string">'./dbconfig'</span>)</span><br><span class="line"><span class="comment">//导入JWT生成token</span></span><br><span class="line"><span class="keyword">const</span> JWT = <span class="built_in">require</span>(<span class="string">"jsonwebtoken"</span>)</span><br><span class="line"><span class="comment">//导入JWT解密</span></span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">"express-jwt"</span>)</span><br><span class="line"><span class="comment">// 请求post和url=localhost:3000/api/register 的注册路由</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; send &#125; = <span class="built_in">require</span>(<span class="string">"process"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/register"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">//接收请求对象携带的数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123; username, pass, email &#125; = req.body;</span><br><span class="line">  <span class="comment">//sqlClient实现连接数据库，并将用户数据插入数据库 并回调函数响应数据</span></span><br><span class="line">  sqlClient(<span class="string">"insert into user values(null,?,?,?)"</span>, [username, pass, email], result =&gt; &#123;</span><br><span class="line">    <span class="comment">//插入成功 并响应对象数据给客户端</span></span><br><span class="line">    <span class="keyword">if</span> (result.affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        status: <span class="number">200</span>,</span><br><span class="line">        msg: <span class="string">"注册成功"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        statu: <span class="number">401</span>,</span><br><span class="line">        msg: <span class="string">"注册失败"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>只需要导入<code>mysql</code>库，即可以实现数据库连接，并向外导出操作数据库的方法对象，该函数返回一个操作结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/dbconfig.js文件</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义连接对象</span></span><br><span class="line"><span class="keyword">const</span> client = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">"localhost"</span>,</span><br><span class="line">  user: <span class="string">"root"</span>,</span><br><span class="line">  password: <span class="string">"puhui"</span>,</span><br><span class="line">  database: <span class="string">"vue_mall"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//定义操作数据库的方法，参数为sql语句，数组数据，回调函数</span></span><br><span class="line"><span class="keyword">const</span> sqlClient = <span class="function">(<span class="params">sql, arr, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  client.query(sql, arr, (error, result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="comment">//发生错误，返回错误信息</span></span><br><span class="line">      <span class="built_in">console</span>.log(error)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功，则调用回调函数返回操作的结果</span></span><br><span class="line">    callback(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sqlClient</span><br></pre></td></tr></table></figure><p>使用 <code>mysql</code> 对象的<code>createConnection</code>方法创建连接数据库对象 <code>client</code>，然后 定义一个<code>sqlClient</code>对象，其中 <code>sqlClient</code> 需要参数<strong>sql语句</strong>，<strong>数组数据</strong>，便会调用回调函数，并返回<strong>sql语句</strong>和<strong>数据</strong>操作数据库的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 声明变量</title>
      <link href="/2022/08/11/%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F/"/>
      <url>/2022/08/11/%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>有<code>3</code>个关键字可以声明变量，<code>var</code> 在所有<code>ECMAScript</code>版本可以使用，而<code>const</code> 、<code>let</code>只能在<code>ECMAScript6</code> 及更晚的版本使用。</p><h2 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h2><p>语法：</p><blockquote><p>单个变量：var message;</p><p>定义多个变量： var message=”x”,found=”y”;</p></blockquote><p>可以同时定义多个变量，用<strong>逗号</strong>割开即可。</p><p>但是值得注意的是，以下方式合法，但是不推荐这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"h1"</span></span><br><span class="line">message = <span class="number">100</span></span><br></pre></td></tr></table></figure><ol><li>函数作用域</li></ol><p><strong>局部变量</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"h1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//出错</span></span><br></pre></td></tr></table></figure><p>使用<code>var</code> 在函数内部定义变量，会变成该函数的局部变量。</p><p><strong>全局变量</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">message = <span class="string">"h1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//h1</span></span><br></pre></td></tr></table></figure><p>函数内部定义变量时，省略 <code>var</code> 关键字，可以创建全局变量。但严格模式下，不能为未声明变量赋值，会报错<code>ReFerenceError</code></p><ol start="2"><li>var 变量提升</li></ol><p>变量提升就是把所有变量声明都拉到函数作用域的顶部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(age);</span><br><span class="line">     <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"> &#125;</span><br><span class="line">test() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>以上代码，不会报错，但是不会输出赋值结果，因为等价于如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(age);</span><br><span class="line">     age = <span class="number">20</span>;</span><br><span class="line"> &#125;</span><br><span class="line">test() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h2 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a>let 关键字</h2><ol><li>块级作用域</li></ol><p><code>let</code> 是块级作用域即“{}”（大括号）之间的作用域。这不同于 <code>var</code> ，<code>var</code>是函数作用域。</p><p><code>var：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'ph'</span></span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">//ph</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">//ph</span></span><br></pre></td></tr></table></figure><p><code>let :</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'ph'</span></span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">//ph</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// 抛出 ReFrenceError ： age没定义</span></span><br></pre></td></tr></table></figure><ol start="2"><li>声明冗余</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age; <span class="comment">//SyntaxError 已经声明过了</span></span><br></pre></td></tr></table></figure><p>但是，有些情况可以重复声明。例如同一个块没有重复声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'zz'</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// zz</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'ph'</span></span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// ph</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明冗余报错不会受混用<code>let</code>和<code>var</code>而影响。这两个关键字生命的并不是不同类型的变量，只是指出变量在相关作用域如何存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">//SyntaxError </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"><span class="keyword">let</span> age; <span class="comment">//SyntaxError</span></span><br></pre></td></tr></table></figure><ol start="3"><li>暂时性死区</li></ol><p><code>let</code>没有变量声明，在<code>let</code> 声明之前的执行瞬间被称为“暂时性死区”，会抛出 <code>ReFrenceError</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">// ReFerenceError: age 没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>全局声明</li></ol><p>和<code>var</code>不同，<code>let</code> 声明的变量不会成为<code>window</code>对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;   </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);<span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ol start="5"><li>条件声明</li></ol><p>不能检查出前面是否已经使用<code>let</code> 声明过同名变量，即使使用<code>try/catch</code>语句或者<code>typeof</code>操作符也不能解决，同时也就是可能是：在没声明的时候声明<code>let</code></p><ol start="6"><li>for 循环中的<code>let</code>声明</li></ol><p><code>let</code> 声明的变量只在当前<strong>{ }</strong>内，括号外不存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">console</span>.log(i)  <span class="comment">// 5 还存在 i 变量</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i&#x3D;0;i&lt;5;i++)&#123; </span><br><span class="line">&#125;</span><br><span class="line"> console.log(i)  &#x2F;&#x2F; ReFrenceError : i 变量未定义</span><br></pre></td></tr></table></figure><p>类似，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">settimeout(<span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(i),<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： 5，5，5，5，5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">settimeout(<span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(i),<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： 0，1，2，3，4</p><h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><p><code>const</code>行为基本和<code>let</code>相同，唯一一个区别是：它声明时必须同时初始化变量，且常识修改<code>const</code>声明的变量回导致运行的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">age = <span class="number">30</span> ;  <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure><p><code>const</code>不允许重复声明 </p><p><code>const</code>声明的变量也是块级作用域</p><p><code>const</code>声明的变量不能用来声明迭代变量，因为，自增意味着修改值，会报错<code>TypeError</code>：给常量赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">&#125; <span class="comment">// TypeError ：给常量赋值。</span></span><br></pre></td></tr></table></figure><p>对于<code>for-in</code>和 <code>for-of</code>循环，每次只是创建新变量，非常有意思</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(key)</span><br><span class="line">&#125; <span class="comment">// a,b</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(const value of [1,2,3,4])&#123;</span><br><span class="line">console.log(value)</span><br><span class="line">&#125; &#x2F;&#x2F; 1,2,3,4</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><table><thead><tr><th align="center">关键字</th><th align="center">作用域</th><th align="center">同一作用域中，重复声明</th><th align="center">声明之前使用变量（是否有变量提升）</th><th align="center">是否能改变量值</th></tr></thead><tbody><tr><td align="center">var</td><td align="center">函数</td><td align="center">可以</td><td align="center">undefined（有）</td><td align="center">可以</td></tr><tr><td align="center">let</td><td align="center">块</td><td align="center">SyntaxError</td><td align="center">ReFerenceError（没有）</td><td align="center">可以</td></tr><tr><td align="center">const</td><td align="center">块</td><td align="center">SyntaxError</td><td align="center">ReFerenceError（没有）</td><td align="center">TypeError（对象类型可以修改，因为地址没变）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css animation</title>
      <link href="/2022/08/10/css%E5%8A%A8%E7%94%BB/"/>
      <url>/2022/08/10/css%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>属性值：</p><blockquote><p>animation-name：设置动画名称</p><p>animation-duration：设置动画完成所需时间，默认为<code>0</code></p><p>animation-timing-function：设置动画的速度曲线，默认为 <code>ease</code>；</p><p>animation-delay：设置动画<code>开始</code>之前的延迟时间，默认为 <code>0</code>；</p><p>animation-iteration-count：设置动画被播放的次数，默认为 <code>1</code>；</p><p>animation-direction：设置是否在下一周期逆向播放动画，默认为 <code>normal</code>；</p><p>animation-fill-mode：设置当动画不播放时（动画播放完或延迟播放时）的状态；</p><p>animation-play-state ：设置动画是正在运行还是暂停，默认是 running；</p><p>animation：所有动画属性的简写属性。</p></blockquote><p>是动画的简写形式，语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">animation-name</span> <span class="selector-tag">animation-duration</span> <span class="selector-tag">animation-timing-function</span> <span class="selector-tag">animation-delay</span> <span class="selector-tag">animation-iteration-count</span> <span class="selector-tag">animation-direction</span> <span class="selector-tag">animation-fill-mode</span> <span class="selector-tag">animation-play-state</span>;</span><br></pre></td></tr></table></figure><p>其中每个参数分别对应上面介绍的各个属性，如果<code>省略</code>其中的某个或多个值，则将使用该属性对应的<code>默认值</code>。</p><p>一般用法足够：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 动画名 、需要5s完成 、线性匀速、动画次数循环次 */</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">name</span> 5<span class="selector-tag">s</span> <span class="selector-tag">linear</span> <span class="selector-tag">infinite</span>;</span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">animation-name</span> <span class="selector-tag">animation-duration</span> <span class="selector-tag">animation-timing-function</span> <span class="selector-tag">animation-iteration-count</span> ;</span><br><span class="line"><span class="comment">/* 动画定义*/</span></span><br><span class="line"><span class="keyword">@keyframes</span> name</span><br><span class="line">&#123;</span><br><span class="line">from &#123; 状态 &#125; // 0%&#123; 状态 &#125;</span><br><span class="line">to &#123; 状态 &#125; // 100%&#123; 状态 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以同时使用多个动画，之间用<code>逗号</code>分割：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小熊动画代码 */</span></span><br><span class="line"><span class="selector-class">.bear</span> &#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">border</span>:  solid <span class="built_in">rgb</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>) <span class="number">1px</span>;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">url</span>(media/bear.png) no-repeat;</span><br><span class="line">            <span class="comment">/* 我们元素可以添加多个动画， 用逗号分隔 */</span></span><br><span class="line">            <span class="attribute">animation</span>: bear <span class="number">1s</span> <span class="built_in">steps</span>(<span class="number">8</span>) infinite,move <span class="number">4s</span> forwards;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">@keyframes</span> bear &#123;</span><br><span class="line">            0% &#123;</span><br><span class="line">                <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            100% &#123;</span><br><span class="line">                <span class="attribute">background-position</span>: -<span class="number">1600px</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">            0% &#123;</span><br><span class="line">                <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            100% &#123;</span><br><span class="line">                <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">                <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">                <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h2><p><code>animation-name</code> 属性用来将动画绑定到指定的 <code>HTML</code> 元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            border-radius: <span class="number">50</span>%;</span><br><span class="line">            border: <span class="number">3</span>px solid black;</span><br><span class="line">            position: relative;</span><br><span class="line">            animation-name: ball;</span><br><span class="line">        &#125;</span><br><span class="line">@keyframes ball &#123;</span><br><span class="line">            <span class="number">0</span>% &#123; <span class="attr">top</span>: <span class="number">0</span>px; left: <span class="number">0</span>px;&#125;</span><br><span class="line">            <span class="number">25</span>% &#123; <span class="attr">top</span>: <span class="number">0</span>px; left: <span class="number">350</span>px;&#125;</span><br><span class="line">            <span class="number">50</span>% &#123; <span class="attr">top</span>: <span class="number">200</span>px; left: <span class="number">350</span>px;&#125;</span><br><span class="line">            <span class="number">75</span>% &#123; <span class="attr">top</span>: <span class="number">200</span>px; left: <span class="number">0</span>px;&#125;</span><br><span class="line">            <span class="number">100</span>% &#123; <span class="attr">top</span>: <span class="number">0</span>px; left: <span class="number">0</span>px;&#125; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过<code>animation-name: ball</code>使用动画</p><h2 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h2><p><code>animation-duration</code> 属性用来设置动画完成一个周期所需要花费的时间，单位为秒或者毫秒。</p><h2 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h2><p><code>animation-timing-function</code> 属性用来设置动画播放的速度曲线，通过速度曲线的设置可以使动画播放的更为平滑。<code>animation-timing-function</code> 属性的可选值如下表所示：</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">linear</td><td align="center">线性匀速</td></tr><tr><td align="center">ease</td><td align="center">默认值，动画以低速开始，然后加快，在结束前变慢</td></tr><tr><td align="center">ease-in</td><td align="center">动画以低速开始</td></tr><tr><td align="center">ease-out</td><td align="center">动画以低速结束</td></tr><tr><td align="center">ease-in-out</td><td align="center">动画以低速开始，并以低速结束</td></tr><tr><td align="center">cubic-bezier(n, n, n, n)</td><td align="center">使用 cubic-bezier() 函数来定义动画的播放速度，参数的取值范围为 0 到 1 之间的数值</td></tr></tbody></table><h2 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h2><p><code>animation-fill-mode</code> 属性用来设置当动画不播放时（开始播放之前或播放结束之后）动画的状态（样式），属性的可选值如下：</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">不改变动画的默认行为</td></tr><tr><td align="center">forwards</td><td align="center">当动画播放完成后，保持动画最后一个关键帧中的样式</td></tr><tr><td align="center">backwards</td><td align="center">在 <code>animation-delay</code> 所指定的时间段内，应用动画第一个关键帧中的样式</td></tr><tr><td align="center">both</td><td align="center">同时遵循 <code>forwards</code> 和 <code>backwards</code> 的规则</td></tr></tbody></table><h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p><code>animation-delay</code> 属性用来定义动画开始播放前的延迟时间，单位为秒或者毫秒，属性的语法格式如下：</p><p>其中参数 <code>time</code> 就是动画播放前的延迟时间，参数 <code>time</code> 既可以为正值也可以为负值。参数值为正时，表示延迟指定时间开始播放；参数为负时，表示跳过指定时间，并立即播放动画。</p><h2 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h2><p><code>animation-iteration-count</code> 属性用来定义动画播放的次数，属性的可选值如下：</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">使用具体数值定义动画播放的次数，默认值为 1</td></tr><tr><td align="center">infinite</td><td align="center">表示动画无限次播放</td></tr></tbody></table><h2 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h2><p><code>animation-direction</code> 属性用来设置是否轮流反向播放动画，属性的可选值如下：</p><p>比如顺时针、逆时针；向左、向右。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>以正常的方式播放动画</td></tr><tr><td>reverse</td><td>以相反的方向播放动画</td></tr><tr><td>alternate</td><td>播放动画时，奇数次（1、3、5 等）正常播放，偶数次（2、4、6 等）反向播放</td></tr><tr><td>alternate-reverse</td><td>播放动画时，奇数次（1、3、5 等）反向播放，偶数次（2、4、6 等）正常播放</td></tr></tbody></table><h2 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h2><p><code>animation-play-state</code> 属性用来设置动画是播放还是暂停，属性的可选值如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>paused</td><td>暂停动画的播放</td></tr><tr><td>running</td><td>正常播放动画</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this 指向和相关函数介绍</title>
      <link href="/2022/08/05/this%20%E6%8C%87%E5%90%91%E5%92%8C%E8%83%BD%E6%94%B9%E5%8F%98%E6%8C%87%E5%90%91%E7%9A%84%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/08/05/this%20%E6%8C%87%E5%90%91%E5%92%8C%E8%83%BD%E6%94%B9%E5%8F%98%E6%8C%87%E5%90%91%E7%9A%84%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>摘要 ：与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。<code>以下都是在非严格模式下</code></p><hr><h1 id="this-指向分为以下几种："><a href="#this-指向分为以下几种：" class="headerlink" title="this 指向分为以下几种："></a>this 指向分为以下几种：</h1><h2 id="A-全局环境"><a href="#A-全局环境" class="headerlink" title="A. 全局环境"></a><code>A.</code> 全局环境</h2><p>   <code>this</code> 都指向全局对象 <code>window</code>。</p><p>   <strong>变量</strong>    <img src="https://img-blog.csdnimg.cn/70308cc7977c4ac58f613061f0bef174.png" alt="在这里插入图片描述">   <strong>函数内部</strong>   <img src="https://img-blog.csdnimg.cn/dccd7229c38e4a99a45aa346bc1cfda1.png" alt=""></p><h2 id="B-构造函数"><a href="#B-构造函数" class="headerlink" title="B.  构造函数"></a><code>B.</code>  构造函数</h2><p>构造函数中的 <code>this</code>，指的是<code>实例对象</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.p = p;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj(<span class="string">'Hello World!'</span>);</span><br><span class="line">o.p  <span class="comment">//'Hello World!'</span></span><br></pre></td></tr></table></figure><h2 id="C-对象的方法"><a href="#C-对象的方法" class="headerlink" title="C. 对象的方法"></a><code>C.</code> 对象的方法</h2><p>  如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。<br>  <strong>简单对象方法</strong><img src="https://img-blog.csdnimg.cn/d78ea66bcf72478295e064f22ec55088.png" alt="在这里插入图片描述"><br>   <strong>事件</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 指向 btn 这个对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>赋值</strong><br><img src="https://img-blog.csdnimg.cn/66d6976941d74e0b85683c99f8615f87.png" alt="在这里插入图片描述"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = a.b.m;</span><br><span class="line">hello() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>m</code> 是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给<code>hello</code>，这样调用时，this 的指向就不会变。<br>改成这个就行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = a.b;</span><br><span class="line">hello.m() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p><strong>立即执行函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="number">1</span>, obj.foo)() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><h1 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h1><p>JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">call</span>(<span class="params">thisArg, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure><p><code>call</code>方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>call</code> 将 f 函数的 this 指向对象 <code>obj</code>，然后在对象 <code>obj</code> 的作用域中运行函数 <code>f</code>。<br><code>call</code> 方法的参数，应该是一个对象。如果参数为<code>空</code>、<code>null</code> 和<code>undefined</code>，则<strong>默认</strong>传入<strong>全局对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ar n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call() <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">null</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">undefined</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="built_in">window</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(obj) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure><p>call方法还可以接受多个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisArg)</span><br><span class="line">func.apply(thisArg, argsArray)</span><br><span class="line"><span class="comment">// call的第一个参数就是 this 所要指向的那个对象，后面的参数则是函数 func 调用时所需的参数。</span></span><br></pre></td></tr></table></figure><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2><p>语法：<br><code>apply</code> 方法的作用与 call 方法类似，也是改变 <code>this</code> 指向，然后再调用该函数。唯一的区别就是：它接收一个数组作为函数执行时的参数，使用格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure><p><code>apply</code> 方法的第一个参数也是this所要指向的那个对象，如果设为 <code>null</code> 或<code>undefined</code>，则等同于指定<code>window</code>。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在 call 方法中必须一个个添加，但是在 <code>apply</code> 方法中，必须以数组形式添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>（1）找出数组最大元素<br>JavaScript 不提供找出<strong>数组最大元素</strong>的函数。结合使用 <code>apply</code> 方法 Math.max方法，就可以返回数组的最大元素。<br>（2）将数组的空元素变为 undefined<br>通过 <code>apply</code> 方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="string">'a'</span>, ,<span class="string">'b'</span>])</span><br><span class="line"><span class="comment">// [ 'a', undefined, 'b' ]</span></span><br></pre></td></tr></table></figure><p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，继续遍历下一个元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。<br>（3）转换类似数组的对象<br>利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2><p>语法：<br><code>bind</code>方法用于将函数体内的 <code>this</code> 绑定到某个对象，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure><p>将实例<code>d</code>的方法赋值给另一个变量<code>print</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime() <span class="comment">// 1481869925657</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.getTime;</span><br><span class="line">print() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>因为<code>getTime</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。<br><code>bind</code>方法可以解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.getTime.bind(d);</span><br><span class="line">print() <span class="comment">// 148186992565</span></span><br></pre></td></tr></table></figure><p>this 绑定其他对象，并调用原方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  count: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.inc.bind(obj);</span><br><span class="line">func();</span><br><span class="line">obj.count <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>bind</code>方法将<code>inc</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。并且赋值、调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。<br><code>bind</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="keyword">this</span>.m + y * <span class="keyword">this</span>.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  m: <span class="number">2</span>,</span><br><span class="line">  n: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newAdd = add.bind(obj, <span class="number">5</span>);</span><br><span class="line">newAdd(<span class="number">5</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>bind</code>方法除了绑定<code>this</code>对象，还将<code>add</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。<br>如果<code>bind</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plus5 = add.bind(<span class="literal">null</span>, <span class="number">5</span>);</span><br><span class="line">plus5(<span class="number">10</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>（1）每一次返回一个新函数<br><code>bind</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, o.m.bind(o));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件绑定<code>bind</code>方法生成的一个匿名函数。通过同样的操作重新<code>bind</code>不再是以前的函数，这样会导致无法取消绑定，所以，下面的代码是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.removeEventListener(<span class="string">'click'</span>, o.m.bind(o)); <span class="comment">// 移除监听点击事件失败</span></span><br></pre></td></tr></table></figure><p>正确写法是下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.m.bind(o);</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, listener);</span><br></pre></td></tr></table></figure><p>（2）结合回调函数使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  times: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()  <span class="comment">// 无输出 全局对象没name属性</span></span><br></pre></td></tr></table></figure><p><code>obj.print</code>内部<code>this.times</code>的this是指向obj的，这个没有问题。但是，<code>forEach</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。<br>如下改动可以解释以上现象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通过<code>bind</code>方法绑定<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure><p>（3）结合 call 方法使用<br>** <code>call</code>、 <code>apply</code>、 <code>bind</code> 不一样的是：若调用<code>call</code> 、<code>apply</code>的原方法没有返回值，则返回 undefined，<code>bind</code> 默认返回新的函数。<br>利用<code>bind</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice</code>方法为例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].slice(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p>将其改写为<code>call、bind</code>结合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.bind(<span class="built_in">Array</span>.prototype.slice);</span><br><span class="line">slice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.slice);</span><br><span class="line">slice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"> <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.push);</span><br><span class="line"><span class="keyword">var</span> pop = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.pop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line">push(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">pop(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind);</span><br><span class="line">bind(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以bind方法就可以直接使用，不需要在函数实例上使用。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise 是如何将异步请求改为同步的 ？</title>
      <link href="/2022/08/01/Promise,%20Async,%20Await/"/>
      <url>/2022/08/01/Promise,%20Async,%20Await/</url>
      
        <content type="html"><![CDATA[<p><code>摘要</code>：同步任务需要等待上一步完成，才能执行下一步，而异步不需要被等待，这样可能会使得在同步任务执行时，异步请求未完成，导致同步未能拿到请求结果而出现错误信息的问题，<code>Promise</code>可以解决此问题，只需要将<code>异步</code>改写为<code>同步</code>，实现等待。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">one</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="string">"1"</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">two</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="string">"2"</span></span></span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">three</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="string">"3"</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(one())</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(two())</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(three())</span></span><br><span class="line">            &#125;</span><br><span class="line">            run()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>1<br>undefined<br>3</p></blockquote><p>出现以上结果的意思是，<code>two</code>方法有请求，但是当执行到<code>console.log(two())</code>的时候，<code>two</code>方法是内部请求是异步的，还没有结果。同步没有等待异步，就输出了<code>undefined</code>。</p><p>按照实际开发中的思路：等待请求完成后才往后执行，换句话是，将异步换成同步执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">"2"</span>) <span class="comment">//请求成功 返回结果</span></span><br><span class="line">      &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成以上代码后，打印结果如下：</p><blockquote><p>1<br>Promise {<pending>}[[Prototype]]: Promise[[PromiseState]]: “pending”[[PromiseResult]]: undefined<br>3</p></blockquote><p>虽然我们将返回结果改为<code>Promise</code>对象，但是同步也没有等待异步请求，状态为：<a href="https://blog.puhuier.xyz/2022/08/01/promise理解/" target="_blank" rel="noopener">pending</a>，请求结果：<code>PromiseResult</code></p><p>下面使用关键字：<code>Async</code>、<code>Await</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">one</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="string">"1"</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">two</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    resolve(<span class="string">"2"</span>)</span></span><br><span class="line">                  &#125;,0)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">three</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="string">"3"</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(one())</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">await</span> two())</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(three())</span></span><br><span class="line">            &#125;</span><br><span class="line">            run()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码的结果：</p><blockquote><p>1<br>2<br>3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> promise </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 promise 的状态</title>
      <link href="/2022/08/01/promise%E7%90%86%E8%A7%A3/"/>
      <url>/2022/08/01/promise%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1>]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟 DOM 和 diff 算法</title>
      <link href="/2022/07/27/virtualDOM/"/>
      <url>/2022/07/27/virtualDOM/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要： 介绍 snabbdom、虚拟 DOM、diff 算法</p></blockquote><p>本文重点是什么 ？</p><blockquote><p>（1）虚拟 <code>DOM</code> 是什么，作用 ？</p><p>（2）虚拟<code>DOM</code>如何产生 ？—— 以<code>h</code> 函数为例（其实，<code>vue.js</code>中有<code>vnode</code>类，可以创建不同类型的<code>vnode</code>实例）</p><p>（3）虚拟<code>DOM</code>最核心，将<code>vnode</code>渲染成真实的<code>DOM</code>— <code>patch</code> 函数</p></blockquote><h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ul><li>介绍：<code>vnode</code>是一个类，可以生成不同类型的<code>vnode</code>实例，而不同类型的<code>vnode</code>表示不同类型的真实<code>DOM</code>元素。  </li><li>类型：真实 <code>DOM</code>有元素节点、文本节点和注释节点等。<code>vnode</code>实例也对应有着元素节点、文本节点和注释节点。</li></ul><blockquote><p>（1）注释节点</p><p>（2）文本节点</p><p>（3）元素节点</p><p>（4）组件节点</p><p>（5）函数式组件</p><p>（6）克隆节点</p></blockquote><ul><li>以<code>元素节点</code>为例，存在4个有效属性：</li></ul><blockquote><p>（1）tag：节点名，例如 <code>p</code>、<code>ul</code>等</p><p>（2）data：包含节点上的数据，比如<code>attrs</code>、<code>class</code>和<code>style</code>等</p><p>（3）children：当前节点的子节点列表</p><p>（4）context：当前组件的的<code>vue.js</code>实例</p></blockquote><p>真实的元素节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>可乐<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的<code>vnode</code>实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    children:[vnode,vnode],</span><br><span class="line">    context:&#123;...&#125;,</span><br><span class="line">    data:&#123;...&#125;,</span><br><span class="line">    tag:<span class="string">"p"</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Vue.js</code>对组件采用了虚拟<code>DOM</code>来更新视图，当属性发生变化时，整个组件都要进行重新渲染操作，但是组件内并不是所有<code>DOM</code>节点都需要更新，因此，只对需要更新的部分进行<code>DOM</code>操作可以提升很多性能。</p><h2 id="虚拟-DOM-做了什么？"><a href="#虚拟-DOM-做了什么？" class="headerlink" title="虚拟 DOM 做了什么？"></a>虚拟 DOM 做了什么？</h2><p>其实没有那么复杂，它主要做了两件事。</p><ol><li>提供与真实<code>DOM</code>节点对应的虚拟节点 <code>vnode</code>;</li><li>将虚拟节点<code>vnode</code>和旧的虚拟节点<code>oldVnode</code>进行对比，更新视图。</li></ol><p>两个虚拟节点之间的对比是虚拟<code>dom</code> 中最核心的算法（<code>patch</code>），它可以判断出哪些节点发生了变化，从而只对变化的节点进行更新操作。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>每次渲染视图时，都是先创建 <code>vnode</code>，然后使用它创建真实的<code>DOM</code>插入到页面中，所以将上一次渲染视图时创建的 <code>vnode</code>存储起来，之后每次重新渲染时，将新旧 <code>vnode</code> 进行对比，</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>区别于<code>真实DOM</code></p><ul><li>无需手动操作 <code>DOM</code>，提高开发效率；</li><li>复杂场景下，防止频繁触发重绘，可以提高性能；</li><li>虚拟 <code>DOM</code> 实际是 <code>JavaScript</code> 对象，可以进行跨平台操作。</li></ul><p><code>问题</code>：数据发生改变，试图怎么更新 ?<br>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有订阅者<code>Watcher</code>(组件)，订阅者们就会调用<code>patch</code>方法，给真实<code>DOM</code>打补丁，更新相应的视图。</p><h1 id="h-函数"><a href="#h-函数" class="headerlink" title="h 函数"></a>h 函数</h1><p>使用<code>snabbdom</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'snabbdom/h'</span> <span class="comment">// helper function for creating vnodes</span></span><br><span class="line"><span class="comment">// 使用 h 函数创建虚拟节点</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(<span class="string">'ul'</span>, &#123;&#125;, [</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'A'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'B'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'C'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'D'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>其中，<code>vnode</code>便是<code>h</code>函数创建的虚拟<code>DOM</code></p><h1 id="patch-函数"><a href="#patch-函数" class="headerlink" title="patch 函数"></a>patch 函数</h1><p>对比两个<code>vode</code>之间的差异只是<code>patch</code>的一部分，只是手段，不是目的。<code>patch</code>的目的是修改<code>DOM</code>节点，可以理解为渲染视图。</p><p>操作：创建节点、删除节点、修改节点。</p><h2 id="创建节点、删除节点："><a href="#创建节点、删除节点：" class="headerlink" title="创建节点、删除节点："></a>创建节点、删除节点：</h2><p>两个虚拟节点完全不同，以新节点为标准渲染视图，是需要执行：将旧节点删除或者创建新增节点。</p><h2 id="修改节点："><a href="#修改节点：" class="headerlink" title="修改节点："></a>修改节点：</h2><p>新旧两个节点相同，需要进行细致化对比，然后对<code>oldVode</code>在新视图中对应的真实节点进行更新。</p><h2 id="diff-函数"><a href="#diff-函数" class="headerlink" title="diff 函数"></a>diff 函数</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p>计算最小更新 DOM 的方式。</p><ul><li>将 DOM 抽象为虚拟 DOM ；</li><li>然后通过新旧虚拟 DOM 这两个对象的差异( Diff 算法)；</li><li>最终只把变化的部分重新渲染,提高渲染效率的过程。</li></ul><p>流程图：<br>其中包含 <code>patch</code> 函数、<code>pachVnode</code> 函数、<code>UpdateVnode</code> 函数（未详细介绍）</p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>使用 snabbdom 虚拟 DOM 库 ：<a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** src/index.js */</span></span><br><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">'snabbdom/init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; classModule &#125; <span class="keyword">from</span> <span class="string">'snabbdom/modules/class'</span></span><br><span class="line"><span class="keyword">import</span> &#123; propsModule &#125; <span class="keyword">from</span> <span class="string">'snabbdom/modules/props'</span></span><br><span class="line"><span class="keyword">import</span> &#123; styleModule &#125; <span class="keyword">from</span> <span class="string">'snabbdom/modules/style'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventListenersModule &#125; <span class="keyword">from</span> <span class="string">'snabbdom/modules/eventlisteners'</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'snabbdom/h'</span> <span class="comment">// helper function for creating vnodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建出 patch 函数</span></span><br><span class="line"><span class="keyword">const</span> patch = init([</span><br><span class="line">  classModule,</span><br><span class="line">  propsModule,</span><br><span class="line">  styleModule,</span><br><span class="line">  eventListenersModule</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 2、使用 h 函数创建虚拟节点</span></span><br><span class="line"><span class="keyword">const</span> vnode1 = h(<span class="string">'ul'</span>, &#123;&#125;, [</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'A'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'B'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'C'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'D'</span>)</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 3.创建空的容器</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="comment">// 4.将 DOM 塞入container</span></span><br><span class="line">patch(container, vnode1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode2 = h(<span class="string">'ul'</span>, &#123;&#125;, [</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'A'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'B'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'C'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'D'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123;&#125;, <span class="string">'E'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击按钮时，将vnode1变为vnode2</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用最小改变 来达到 新的vnode 覆盖 旧的 vnode2</span></span><br><span class="line">  patch(vnode1, vnode2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patch-函数-1"><a href="#patch-函数-1" class="headerlink" title="patch 函数"></a>patch 函数</h3><p>接收参数存在： element（真实 DOM ） 和 vnode（虚拟 DOM ） 两种类型<br><code>首次插入</code>：判断 key 和 sel 是相同（2种情况）</p><table><thead><tr><th></th><th>1、vnode.key 和 vnode.sel 都相同</th><th>2、vnode.key 或 vnode.sel 不同</th></tr></thead><tbody><tr><td>是否同一个Vnode</td><td>是</td><td>否</td></tr><tr><td>结果</td><td>更新(调用 <code>pachVnode</code> )</td><td>创建新的DOM，删除老的DOM</td></tr></tbody></table><h3 id="pachVnode-函数"><a href="#pachVnode-函数" class="headerlink" title="pachVnode 函数"></a>pachVnode 函数</h3><p><strong>虚拟节点 text 和 children 最多只能有一个</strong></p><ol><li>保存（旧的相关联）的 DOM 元素 eml 给新的 Vnode（eml 记录新的 Vnode 插入位置）</li><li>比较新、旧 vnode 的 children 情况（3种情况）</li></ol><table><thead><tr><th align="left"></th><th align="left">1、新 vnode === 旧 vnode（全等）</th><th align="left">2、新 Vnode 无 text</th><th align="left">3、新 Vnode 有 text</th></tr></thead><tbody><tr><td align="left">结果</td><td align="left">不需更新，return</td><td align="left">1.新、老 Vnode 都有 children，即调用（<code>updateChildren</code>）；<br>2.老 Vnode 无 children，即添加 children ；<br>3.新的无 children ，即删除 children</td><td align="left">删除 children ，更新新的 text</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>易错题集</title>
      <link href="/2022/07/16/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/16/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h1><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="js概念与类型检测"><a href="#js概念与类型检测" class="headerlink" title="js概念与类型检测"></a>js概念与类型检测</h3><ol><li><p>以下不属于 typeof 运算符返回值的是？</p><p>A. “string”<br>B. “function”<br>C. “object”<br>D. “null”</p><blockquote><p>typeof 引用类型只能识别 function</p></blockquote></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git远程仓库已有提交文件，如何提交本地仓库覆盖远程仓库</title>
      <link href="/2022/07/12/git%20%E4%BB%93%E5%BA%93%E5%86%B2%E7%AA%81/"/>
      <url>/2022/07/12/git%20%E4%BB%93%E5%BA%93%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<h1 id="首次提交到远程仓库的正常流程："><a href="#首次提交到远程仓库的正常流程：" class="headerlink" title="首次提交到远程仓库的正常流程："></a>首次提交到远程仓库的正常流程：</h1><ol><li><p><code>新建（初始化本地仓库）</code></p><blockquote><p>命令：git init</p><p>结果：根目录出现 .git 文件（即本 地仓库）</p></blockquote></li></ol><ol start="2"><li><p><code>跟踪文件</code></p><blockquote><p>命令：git add . </p><p>是跟踪根目录下所有文件</p></blockquote></li><li><p><code>提交到本地仓库</code></p><blockquote><p>命令：git commit -m  “这里可以写备注以便代码管理”</p></blockquote></li><li><p><code>连接远程仓库</code></p><blockquote><p>命令：git remote add origin httpXXXXX.git </p><p> origin 的意思是指“远程仓库”，就是远程仓库链接的别名，是在 clone 一个托管在 Github 上代码库时，git 默认创建的指向这个远程代码库的标签，origin 指向的就是本地的代码库托管在 Github 上的版本。</p></blockquote></li><li><p><code>提交到本地仓库</code></p><blockquote><p>命令：git push -u origin master</p><p>提交到远程仓库的 master 分支</p></blockquote></li></ol><h1 id="报错出现仓库提交失败信息如下："><a href="#报错出现仓库提交失败信息如下：" class="headerlink" title="报错出现仓库提交失败信息如下："></a>报错出现<font color="green">仓库提交失败信息如下：</font></h1><blockquote><p>To <a href="https://gitee.com/XXXXXX.git" target="_blank" rel="noopener">https://gitee.com/XXXXXX.git</a><br> ! [rejected]        master -&gt; master (fetch first)<br>error: failed to push some refs to ‘<a href="https://gitee.com/XXXXXX.git&#39;" target="_blank" rel="noopener">https://gitee.com/XXXXXX.git&#39;</a><br>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决:"></a><font color="green">解决:</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f 远程仓库名  远程仓库分支</span><br></pre></td></tr></table></figure><blockquote><p>使用本地仓库文件覆盖远程仓库,即强制推送。</p></blockquote><p>以上代码中的<code>远程仓库名</code>和<code>分支</code>，获取方式如下：</p><ul><li><p>远程仓库名，查看：git remote show</p></li><li><p>远程仓库分支，查看：git branch（带有星号的分支，代表当前分支）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题（http 部分）</title>
      <link href="/2022/05/09/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88http%20%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2022/05/09/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88http%20%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><center>HTTP</h1><h2 id="HTTP-报文结构是怎么样-？"><a href="#HTTP-报文结构是怎么样-？" class="headerlink" title="HTTP 报文结构是怎么样 ？"></a>HTTP 报文结构是怎么样 ？</h2><p>对于 <code>TCP</code> 而言，在传输的时候分为两部分：<code>TCP 头</code>+<code>数据部分</code></p><p>而 <code>HTTP</code>而言，也是 <code>header + body</code> 结构，具体：</p><blockquote><p>起始行 + 头部 +  空行 + 实体</p></blockquote><p>由于 <code>HTTP</code> 的<code>请求报文</code>、<code>响应报文</code>存在区别，因此按照结构逻辑进行介绍:</p><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><ol><li>对于<code>请求报文</code>，起始行类似于：</li></ol><blockquote><p>① GET  /home  HTTP/1.1   </p></blockquote><p>也就是 <strong>方法</strong>+<strong>路径</strong>+<strong>HTTP版本</strong>。</p><ol start="2"><li>对于<code>响应报文</code>，起始行一般是：</li></ol><blockquote><p>② HTTP/1.1  200  OK</p></blockquote><p>响应的报文的起始行也叫做<code>状态行</code>：由<code>HTTP版本</code>、<code>状态码</code>、<code>原因</code>三部分组成。</p><p>观察 <code>①</code>、<code>②</code> ，每两个部分之间用<strong>空格</strong>隔开，最后一部分后面应该接一个<strong>换行</strong>，严格遵守<code>ABNF</code>语法规范。</p><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>如图所示，头部处于报文中部：</p><p>下面的图中的<strong>请求体</strong>，实际是<strong>请求头部</strong>，和响应头格式一样，请求体是<strong>实体</strong>部分：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp5.itc.cn%2Fimages03%2F20200523%2F125b84668a3d41318d222163a7cf6092.jpeg&refer=http%3A%2F%2Fp5.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1662725810&t=dabcf7548f4d944bb8c67531c5ba5ff5" alt="请求报文"></p><p><strong>响应报文</strong>，SP 是空格，CRLF 是空格。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.136.la%2F20210424%2F2bd8ce0d741840f68105548d3cff7e67.jpg&refer=http%3A%2F%2Fimg.136.la&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1662725750&t=3b88ac87152cceff2da3df3b6199e18c" alt="响应报文"></p><p>由此，请求、响应报文字段都是相当多的，而且牵扯到<code>HTTP</code>很多特性，重点看看这些头部字段的格式：</p><ol><li>字段名<strong>不区分</strong>大小写</li><li>字段名不允许出现<strong>空格</strong>、<strong>下划线</strong>“_”</li><li>字段名后面必须紧跟”<strong>:</strong>“</li></ol><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>很重要，用来区分：<strong>头部</strong>和<strong>实体</strong></p><blockquote><p>问题：如果在头部的中间故意加上一个空行会怎么样？</p><p>答案：那么空行后的内容全部视为实体</p></blockquote><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>就是具体的数据了，也就是<code>body</code>部分，请求报文对应的<strong>请求体</strong>，响应报文对应的<strong>响应体</strong></p><h2 id="HTTP-有哪些请求方法？"><a href="#HTTP-有哪些请求方法？" class="headerlink" title="HTTP 有哪些请求方法？"></a>HTTP 有哪些请求方法？</h2><p><code>HTTP/1.1</code>规定了以下请求方法（注意：都是大写）</p><blockquote><p>GET：用来获取资源</p><p>HEAD： 获资源的元信息</p><p>POST：提交数据，即上传数据</p><p>PUT：修改数据</p><p>DELETE：删除资源（几乎用不上）</p><p>CONNECT：建立连接隧道，用于代理服务器</p><p>OPTIONS：列出可对资源实行的请求方法，用来跨域请求</p><p>TRACE：追踪 请求-响应 的传输路径</p></blockquote><h2 id="GET、POST-有什么区别-？"><a href="#GET、POST-有什么区别-？" class="headerlink" title="GET、POST 有什么区别 ？"></a>GET、POST 有什么区别 ？</h2><p>首先是语义上的区别：</p><blockquote><p>分别是获取资源和提交数据。</p></blockquote><p>其次是具体差别：</p><blockquote><p><strong>缓存</strong>：<code>GET</code> 请求会被浏览器注定缓存下来，留下历史记录，而 <code>POST</code> 默认不会</p><p><strong>编码</strong>：<code>GET</code>只进行<code>URL</code>编码，只接收<code>ASCII</code>字符，而<code>POST</code>没有限制</p><p><strong>参数</strong>：<code>GET</code>一般放在<code>URL</code>中，因此不安全，<code>POST</code>放在请求体中，更适合放敏感信息</p><p><strong>幂等性</strong>：幂等表示相同的操作，结果也是相同的，<code>GET</code>是幂等，而<code>POST</code>不是</p><p><code>TCP</code>：<code>GET</code>请求会把请求一次性发出去，<code>POST</code>会分为两次<code>TCP</code>数据包，首先发<code>header</code>部分，如果服务器响应<code>100</code>（continue），然后再发<code>body</code>部分。（火狐浏览器的<code>POST</code>请求只发一个<code>TCP</code>包）</p></blockquote><h2 id="URI-是什么-？"><a href="#URI-是什么-？" class="headerlink" title="URI 是什么 ？"></a>URI 是什么 ？</h2><p><img src="https://img.php.cn/upload/article/000/000/024/5c09e320694b4361.jpg" alt=""></p><p><code>URL</code>（Uniform Resouce Locator，统一资源定位符）</p><p><code>URN</code>（Uniform Resouce Name，统一资源名）</p><p><code>URI</code>（Uniform Resouce Identifier，统一资源标识符），作用：区分互联网上不同的资源，但是，他并不是我们常说的<strong>网址</strong>，网址指的是<code>URL</code>，<code>URI</code>由<code>URL</code>和<code>URN</code>组成，由于<code>URL</code>过于普及，就默认<code>URI</code>是为<code>URL</code>了。</p><ol><li>URI 的结构</li></ol><p><code>URI</code>真正完整的结构是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme：[&#x2F;&#x2F; [user：password @] host [：port]] [&#x2F;] path [?query] [#fragment]</span><br></pre></td></tr></table></figure><blockquote><p>scheme ：表示协议，比如<code>http</code>、<code>https</code>、<code>file</code>等等。后面跟 <code>://</code></p><p>user:password@：表示登陆主机时用户信息，不过很不安全，不常用</p><p>host：主机名</p><p>port：端口号</p><p>path：请求路径，标记资源所在位置</p><p>query：查询参数，以<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>相隔</p><p>fragment：表示<code>URI</code>所定位的资源内的一个锚点，浏览器可以根据这个描点跳转到指定位置</p></blockquote><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=HTTP&amp;rsv_spt=1</span><br></pre></td></tr></table></figure><p>这个<code>URI</code>中，<code>https</code>协议，<code>www.baidu.com</code>表示域名、端口号（注意：<code>http</code> 和 <code>https</code> 的默认端口分别为<code>80</code>、<code>443</code>），<code>/s</code>表示<code>path</code>，<code>wd=HTTP&amp;rsv_spt=1</code>表示查询参数部分。</p><ol start="2"><li>URI 编码</li></ol><p><code>URI</code>只能使用<code>ASCII</code>，<code>ASCII</code>之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理会导致解析错误。</p><p>因此，<code>URI</code>进入了编码机制，将所有<strong>非<code>ASCII</code>码字符</strong>和<strong>界定符</strong>转为<code>16</code>进制字节值，然后在前面加上<code>%</code>。</p><p>如：<strong>空格</strong>被转义为<code>%20</code>，<strong>三元</strong>转移成为<code>%E4%B8%89%E5%85%83</code>。</p><h2 id="如何理解-HTTP-状态码-？"><a href="#如何理解-HTTP-状态码-？" class="headerlink" title="如何理解 HTTP 状态码 ？"></a>如何理解 HTTP 状态码 ？</h2><p><code>RFC</code> 规定 <code>HTTP</code> 的状态码为<strong>三位数</strong>，被分为以下五类：</p><blockquote><p>1XX：表示目前是协议处理的中间状态，还需后续操作；</p><p>2XX：表示成功状态；</p><p>3XX：表示重定向状态，资源位置发生变动，需要<strong>重新</strong>请求；</p><p>4XX：表示请求报文错误；</p><p>5XX：表示服务器端发生错误</p></blockquote><p>具体的状态码如下：</p><ol><li>协议处理的中间状态，还需后续操作</li></ol><p><code>101</code>： <strong>Switching Protocols</strong> 。在<strong>HTTP</strong>升级为<strong>webSocket</strong>的时候，如果服务器同意变更，就会发送状态码101。</p><ol start="2"><li>成功状态</li></ol><p><code>200</code> ：<strong>OK</strong>是见得最多的成功状态码，通常在响应体中放有数据；</p><p><code>202</code>：<strong>No Content</strong>含义与<code>200</code>相同，但是响应头后没有<code>body</code>数据；</p><p><code>206</code>：<strong>partial Content</strong>，表示部分内容，它的使用场景为<code>HTTP</code>分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code></p><ol start="3"><li>重定向状态</li></ol><p><code>301</code>：<strong>Permanently Moved</strong>，即永久重定向</p><p><code>302</code>： <strong>Temporarily Moved</strong>，即临时重定向。</p><p>比如你的网站从<code>HTTP</code>升级到<code>HTTPS</code>了，以前的站点再也不用了，应当返回<code>301</code>，这时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p><p>而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，浏览器并不会做缓存优化。</p><p><code>304</code>：<strong>Not Modified</strong>：当协商缓存命中时会返回这个状态码。</p><blockquote><p>使用301跳转的场景：</p><p>1）域名到期不想续费（或者发现了更适合网站的域名），想换个域名。<br>2）在搜索引擎的搜索结果中出现了不带<code>www</code>的域名，而带<code>www</code>的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。<br>3）空间服务器不稳定，换空间的时候。</p><p>使用302跳转的场景：</p><ul><li>尽量使用301跳转！<a href="https://www.cnblogs.com/tongongV/p/10944414.html" target="_blank" rel="noopener">点击查看解释</a></li></ul></blockquote><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="什么是跨域、怎么解决跨域问题-？"><a href="#什么是跨域、怎么解决跨域问题-？" class="headerlink" title="什么是跨域、怎么解决跨域问题 ？"></a>什么是跨域、怎么解决跨域问题 ？</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 手写点击高亮</title>
      <link href="/2022/05/07/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%B7%BB%E5%8A%A0%E9%AB%98%E4%BA%AE/"/>
      <url>/2022/05/07/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%B7%BB%E5%8A%A0%E9%AB%98%E4%BA%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"chooerr-list"</span>&gt;</span><br><span class="line">      &lt;li :<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;active:nowIndex === item.id&#125;"</span> </span><br><span class="line">          v-<span class="keyword">for</span>=<span class="string">"(item) in timerDate"</span> </span><br><span class="line">          :key=<span class="string">"item.id"</span> </span><br><span class="line">          @click=<span class="string">"timerHandle(item.id)"</span></span><br><span class="line">       &gt; &#123;&#123;item.value&#125;&#125; </span><br><span class="line">       &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p><img src="/img/1657892137824.png" alt="65789213782"></p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">timerDate:[&#123;</span><br><span class="line">       id:<span class="number">0</span>,</span><br><span class="line">       value:<span class="string">'一个月'</span></span><br><span class="line">     &#125;,&#123;</span><br><span class="line">       id:<span class="number">1</span>,</span><br><span class="line">       value:<span class="string">'三个月'</span></span><br><span class="line">     &#125;,&#123;</span><br><span class="line">       id:<span class="number">2</span>,</span><br><span class="line">       value:<span class="string">'六个月'</span></span><br><span class="line">     &#125;,&#123;</span><br><span class="line">       id:<span class="number">3</span>,</span><br><span class="line">       value:<span class="string">'九个月'</span></span><br><span class="line">     &#125;]</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  timerHandle(data)&#123;</span><br><span class="line">    <span class="keyword">this</span>.nowIndex=data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>添加meta控制用户访问权限</title>
      <link href="/2022/05/07/%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90/"/>
      <url>/2022/05/07/%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤梳理"><a href="#步骤梳理" class="headerlink" title="步骤梳理"></a>步骤梳理</h1><ol><li>在路由模块 router 添加 meta 对象，设置权限属性</li><li>路由守卫 beforeEach ( ) 设置路由跳转逻辑</li></ol><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p><code>以home首页为例做介绍</code></p><h2 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h2><p>思路：每个组件实例存在一个 $route 对象，是一个局部对象，存储组件路由信息： name、meta、path、hash、query、params、fullPath 等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">    name: <span class="string">'Home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      isLogin: <span class="literal">true</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;，</span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/login'</span>,</span><br><span class="line">    name: <span class="string">'Login'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"@/views/login.vue"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>思路：使用前置守卫<font color="green"> beforeEach </font>能在路由跳转<code>前</code>进行拦截的特性，对添加了 meta.isLogin==true 权限的路由进行判断，如果本地存储有 token 值，则next() 通行，否则拦截的路由将跳转到 login 页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.meta.isLogin) &#123;</span><br><span class="line">    <span class="keyword">let</span> token = store.state.login.user.token</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        name: <span class="string">"Login"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>使用 jsonwebtoken（JWT）生成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> JWT = <span class="built_in">require</span>(<span class="string">"jsonwebtoken"</span>)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/login"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, pass &#125; = req.body;</span><br><span class="line">  <span class="comment">//sqlClient方法实现连接数据库并返回查询结果，并回调函数响应数据</span></span><br><span class="line">  sqlClient(<span class="string">"select * from user where username=? and password=?"</span>, [username, pass], result =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> token = JWT.sign(username, <span class="string">'^8^'</span>)</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        token,</span><br><span class="line">        status: <span class="number">200</span>,</span><br><span class="line">        username</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        ststus: <span class="number">401</span>,</span><br><span class="line">        mgs: <span class="string">'登陆失败'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求的状态码那些事</title>
      <link href="/2022/04/10/ajax_readyState/"/>
      <url>/2022/04/10/ajax_readyState/</url>
      
        <content type="html"><![CDATA[<h1 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0（未初始化）: 请求未初始化，还没有调用 send() 方法</span><br><span class="line">1（载入）: 服务器连接已建立，已调用 send() 方法，正在发送请求</span><br><span class="line">2（载入完成）: 请求已接收 接收到了响应头，send() 方法执行完成，已经接收到全部响应内容</span><br><span class="line">3（交互）: 请求处理中 正在下载响应体</span><br><span class="line">4（完成）: 请求已完成，且响应已就绪</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经（CSS 部分）</title>
      <link href="/2022/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88CSS%EF%BC%89/"/>
      <url>/2022/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88CSS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[ 摘要 ]：包含 CSS、JavaScript、vue、计算机网络等知识，全文以问答的风格，书写内容基本涵盖大部分面试题。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="为什么使用浮动-？"><a href="#为什么使用浮动-？" class="headerlink" title="为什么使用浮动 ？"></a>为什么使用浮动 ？</h3><p>一开始出现浮动只是为了解决文字环绕图片问题，但最后是为了解决几个块级元素并排显示问题，虽然定义块级元素的<code>display</code>为<code>inline-block</code>（这种方式也不会出现父级元素坍塌问题）但是这种方式不能控制元素的位置而是默认从左到右，所以要实现元素是居左还是居右使用浮动更方便。</p><h3 id="浮动布局的优点-？"><a href="#浮动布局的优点-？" class="headerlink" title="浮动布局的优点 ？"></a>浮动布局的优点 ？</h3><p>在图文混排的时候可以很好的使文字环绕在图片周围</p><h3 id="缺点-？"><a href="#缺点-？" class="headerlink" title="缺点 ？"></a>缺点 ？</h3><p>浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。</p><h3 id="清除浮动有哪些方式-？"><a href="#清除浮动有哪些方式-？" class="headerlink" title="清除浮动有哪些方式 ？"></a>清除浮动有哪些方式 ？</h3><p>1、添加额外标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    //添加额外标签并且添加 clear 属性</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    //也可以加一个br标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、父级添加<code>overflow</code>属性，或者设置高度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span> <span class="attr">style</span>=<span class="string">"overflow:hidden"</span>&gt;</span>//auto 也可以</span><br><span class="line">    //将父元素的 overflow 设置为 hidden</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"f"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、建立伪类选择器清除浮动（推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//在css中添加:after伪元素</span></span><br><span class="line">    .parent:after&#123;</span><br><span class="line">        <span class="comment">/* 设置添加子元素的内容是空 */</span></span><br><span class="line">        content: <span class="string">''</span>;</span><br><span class="line">        <span class="comment">/* 设置添加子元素为块级元素 */</span></span><br><span class="line">        display: block;</span><br><span class="line">        <span class="comment">/* 设置添加的子元素的高度0 */</span></span><br><span class="line">        height: <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 设置添加子元素看不见 */</span></span><br><span class="line">        visibility: hidden;</span><br><span class="line">        <span class="comment">/* 设置clear：both */</span></span><br><span class="line">        clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"f"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC ?"></a>什么是 BFC ?</h3><p>BFC （block formatting context）块级格式化上下文，是一块独立渲染区域，内部元素的渲染不会影响到外界</p><h3 id="形成-BFC-的条件-？"><a href="#形成-BFC-的条件-？" class="headerlink" title="形成 BFC 的条件 ？"></a>形成 BFC 的条件 ？</h3><p>以下任意一个属性将会触发 BFC</p><ul><li>根元素（<code>&lt;html&gt;</code>）</li><li>浮动元素（<code>float</code> 值不是 <code>none</code>）</li><li>定位元素（<code>position</code> 为 <code>absolute</code> / <code>flxed</code>）</li><li>块级元素（<code>display</code> 为 <code>inline-block</code>）</li><li>display 为：<code>table</code> 、<code>inline-table</code>、<code>table-cell</code> 、<code>table-caption</code> 、<code>flex</code>、<code>inline-flex</code>、<code>grid</code>、<code>inline-grid</code></li><li>overflow 除了为 visible 的值 （为<code>auto</code>、<code>scroll</code>、<code>hidden</code>）</li><li>……</li></ul><h3 id="BFC-应用场景（作用）-？"><a href="#BFC-应用场景（作用）-？" class="headerlink" title="BFC 应用场景（作用） ？"></a>BFC 应用场景（作用） ？</h3><ul><li>防止浮动导致的父盒子高度<strong>塌陷</strong>（清除浮动）</li><li>避免元素垂直方向的外边距<strong>重叠</strong>（重叠后的边距是上下盒子的 margin-bottom、margin-top 中的最大值）</li><li>阻止元素被浮动元素<strong>覆盖</strong></li></ul><h2 id="绘制特殊图形"><a href="#绘制特殊图形" class="headerlink" title="绘制特殊图形"></a>绘制特殊图形</h2><h3 id="border-绘制三角形-？"><a href="#border-绘制三角形-？" class="headerlink" title="border 绘制三角形 ？"></a>border 绘制三角形 ？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.triangle</span>&#123;</span></span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border: 50px solid;</span><br><span class="line">    // 四个参数对应 ：上 右 下 左</span><br><span class="line"><span class="css"><span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-id">#ccc</span> <span class="selector-tag">transparent</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"triangle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：是一个三角形</p><h3 id="skew-绘制平行四边形-？"><a href="#skew-绘制平行四边形-？" class="headerlink" title="skew 绘制平行四边形 ？"></a>skew 绘制平行四边形 ？</h3><p>利用 skew 特性，参数一：x 轴倾斜角度，参数二：y 轴倾斜角度</p><ul><li>skew ( x-angle , y-angle ) 定义沿着 X 和 Y 轴的 2D 倾斜转换。</li><li>skewX ( angle ) 定义沿着 X 轴的 2D 倾斜转换。</li><li>skewY ( angle ) 定义沿着 Y 轴的 2D 倾斜转换。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.parallel</span> &#123;</span></span><br><span class="line">    margin-top: 50px;</span><br><span class="line">    margin-left: 50px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">    transform: skew(-20deg, 0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parallel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用-DIV-绘制五角星-？"><a href="#用-DIV-绘制五角星-？" class="headerlink" title="用 DIV 绘制五角星 ？"></a>用 DIV 绘制五角星 ？</h3><p>思路：用 border 绘制 3 个三角形，其中 2 个三角形旋转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#star</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: transparent transparent red transparent;</span><br><span class="line">    border-width: 70px 100px;</span><br><span class="line">    transform: rotate(35deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#star</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    content: '';</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    top: -128px;</span><br><span class="line">    left: -95px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: transparent transparent red transparent;</span><br><span class="line">    border-width: 80px 30px;</span><br><span class="line">    transform: rotate(-35deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#star</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    content: '';</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    top: -45px;</span><br><span class="line">    left: -140px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: transparent transparent red transparent;</span><br><span class="line">    border-width: 70px 100px;</span><br><span class="line">    transform: rotate(-70deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"star"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas 获取某列前 n 位字符串</title>
      <link href="/2021/11/12/pandas%20%E8%8E%B7%E5%8F%96%E6%9F%90%E5%88%97%E5%89%8D%20n%20%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/12/pandas%20%E8%8E%B7%E5%8F%96%E6%9F%90%E5%88%97%E5%89%8D%20n%20%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="只需三步"><a href="#只需三步" class="headerlink" title="只需三步"></a>只需三步</h1><ul><li>1、指定列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book_id=df.pop(<span class="string">'索书号'</span>)  //定义book_id获取索书号列</span><br></pre></td></tr></table></figure><ul><li>2、<code>book_id</code> 重新取值，取索书号列第一位字符（从索引<code>0</code>开始取，包括第<code>0</code>个）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book_id=book_id.str[:<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>3、在第二列新增<code>book_id</code>列，并填充</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*用book_id填充*&#x2F;</span><br><span class="line">df.insert(1,&#39;book_id&#39;,book_id)</span><br></pre></td></tr></table></figure><ul><li>完整代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">//导入数据</span><br><span class="line">fpath=<span class="string">'xx.xlsx'</span></span><br><span class="line">df=pd.read_excel(fpath)</span><br><span class="line">df.set_index(<span class="string">"序号"</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定列插入某列前n位字符串</span></span><br><span class="line">book_id=df.pop(<span class="string">'索书号'</span>)  //book_id获取索书号列</span><br><span class="line">//  book_id重新取值，取索书号列第一位字符</span><br><span class="line">book_id=book_id.str[:<span class="number">1</span>]</span><br><span class="line">//在第二列新增book_id列并用book_id（第一位字符）填充</span><br><span class="line">df.insert(<span class="number">1</span>,<span class="string">'book_id'</span>,book_id)</span><br><span class="line">//按照book_id列对新增的”类别“列填充类别，我自定义的函数get_classify没写出（按照book_id的值，返回对应“类别”名）</span><br><span class="line">df.loc[:,<span class="string">"类别"</span>]=df.loc[:,<span class="string">'book_id'</span>].apply(get_classify)</span><br><span class="line">//输出</span><br><span class="line">df.to_excel(<span class="string">"111.xlsx"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>同更新于<code>csdn</code> 博客地址：<a href="https://blog.csdn.net/puhuihui/article/details/116668168" target="_blank" rel="noopener">piaoHuiEr</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据处理</title>
      <link href="/2021/09/30/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/09/30/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p> 1、行列基本操作</p><ul><li><p>取指定行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_GD = df1[df1[<span class="string">'city'</span>] == <span class="string">"广东"</span>]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>删除某列为指定值的所有行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df=df[~df[<span class="string">'Year'</span>].isin([<span class="string">'2111'</span>,<span class="string">'9'</span>,<span class="string">'2105'</span>,<span class="string">'板塔结合'</span>,<span class="string">'NaN'</span>,<span class="string">'板楼'</span>,<span class="string">'暂无数据'</span>])]</span><br></pre></td></tr></table></figure></li><li><p>删除某列为<code>NAN</code>（空值）的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df[df[<span class="string">'Year'</span>].notnull()]</span><br></pre></td></tr></table></figure></li><li><p>将非连续性数据分箱（分组）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'Year'</span>] = pd.qcut(df[<span class="string">'Year'</span>],<span class="number">8</span>).astype(object)</span><br></pre></td></tr></table></figure></li><li><p>改变某列数值类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'Year'</span>] = df[<span class="string">'Year'</span>].astype(<span class="string">'int'</span>)</span><br></pre></td></tr></table></figure><p>注意：存在空值或者字符串需要删除才能转为 <code>int/float</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array 封装栈、队列</title>
      <link href="/2021/08/07/%E6%A0%88/"/>
      <url>/2021/08/07/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>摘要：<code>栈和队列都可以基于数组、链表封装，本文只基于数组封装</code></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="封装栈"><a href="#封装栈" class="headerlink" title="封装栈"></a>封装栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//push()添加一个新元素到栈顶位置</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//pop()删除栈顶元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//peek()查看栈顶元素，不移除</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//isEmpty()栈内是否有元素 真为true 返回false</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//size()返回栈元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Bin2</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> number = num</span><br><span class="line">  <span class="comment">//1.创建栈结构</span></span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="comment">//2.循环取余</span></span><br><span class="line">  <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = num % <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 想下取整 相当于整除</span></span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num / <span class="number">2</span>)</span><br><span class="line">    stack.push(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.拼接字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    str += stack.pop()</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(number, <span class="string">'转化为二进制是'</span>, str)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">import</span> &#123; Stack, Bin2 &#125; <span class="keyword">from</span> <span class="string">'./stack'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------stack----------------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.push(<span class="string">'aaa'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(stack.push(<span class="number">222</span>))</span><br><span class="line"><span class="built_in">console</span>.log(stack.push(<span class="string">'ccc'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'长度:'</span>, stack.size()) <span class="comment">// 长度: 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'栈:'</span>, stack.items) <span class="comment">//栈: (3) ['aaa', 222, 'ccc']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'栈顶'</span>, stack.peek()) <span class="comment">//栈顶 ccc</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'删除栈顶'</span>, stack.pop()) <span class="comment">//删除栈顶 ccc</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.items) <span class="comment">//(2) ['aaa', 222]</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Bin2(<span class="number">100</span>) <span class="comment">//100 '转化为二进制是' '1100100'</span></span><br></pre></td></tr></table></figure><p><code>知识来源于哔哩哔哩up主：coderwhy</code></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装队列  :打印机</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue() 像队列尾部添加一个或多个新的(项)</span></span><br><span class="line">  enqueue(element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// dequeue() 移除队首元素,并返回被移除元素</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// front()返回队首元素</span></span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//isEmpty() 是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//size()队列包含的元素个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用封装的队列"><a href="#调用封装的队列" class="headerlink" title="调用封装的队列"></a>调用封装的队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Queue &#125; <span class="keyword">from</span> <span class="string">'./queue'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------queue--------------'</span>)</span><br><span class="line">queue.enqueue(<span class="string">'222'</span>)</span><br><span class="line">queue.enqueue(<span class="number">2</span>)</span><br><span class="line">queue.enqueue(<span class="number">3</span>)</span><br><span class="line">queue.enqueue(<span class="string">'111'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(queue.items)</span><br><span class="line"><span class="built_in">console</span>.log(queue.front())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中的不同数据类型运算问题</title>
      <link href="/2020/09/14/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/14/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>不同类型的数据进行运算，如果一个运算符两侧的数据类型不同，需要先自动进行类型转换，使两者具有同一类型，然后进行运算，现将规律总结如下：</p><blockquote><p>系统有默认的转化规则，就是从精度底的转化为精度高的，避免计算时精度的丢失 具体转换规则如下 char  –&gt; short  –&gt; int —&gt; unsigned  –&gt; long –&gt; unsigned long –&gt; float –&gt; double</p></blockquote><ol><li><p>+、-、 *、 /运算的两个数中有一个数为float或double型，结果是double型，因为系统将所有float型数据都先转换为double型，然后进行运算；</p></li><li><p>若int型与float或double型数据进行运算，先将int型和float型转换为double型，然后进行运算，结果为double型；</p></li><li><p>Char型与int型数据进行运算，就是把字符的ASCII码与整型数据进行运算;</p><pre><code>如：20+&apos;B&apos;=20+66=86</code></pre></li><li><p>两个int型相除，不管是否有余数，结果都为整型；如：5/10 输出是整数部分：0</p></li><li><p>强制类型转换的一般形式为：（类型名）（表达式），将表达式整体的输出结果转换，若写成(int)x+y，则是将x先转换为整型，再与y想加，</p></li></ol><blockquote><p>如上试中： 5/10的输出结果为：0</p><pre><code>  5.0/10的输出结果为：0.5  (fioat)(5/10)的输出结果为：0.00（float）5/10的输出结果为：0.5</code></pre><p>原文<a href="https://zhidao.baidu.com/question/1836994548785755700.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1836994548785755700.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C 语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装、部署</title>
      <link href="/2020/09/14/hexo%E5%AE%89%E8%A3%85/"/>
      <url>/2020/09/14/hexo%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="主要流程如下："><a href="#主要流程如下：" class="headerlink" title="主要流程如下："></a>主要流程如下：</h2><ul><li>Node环境搭建</li><li>Hexo安装</li><li>Git环境搭建</li><li>将项目部署到github</li></ul><h2 id="Node-js安装及环境搭建"><a href="#Node-js安装及环境搭建" class="headerlink" title="Node.js安装及环境搭建"></a>Node.js安装及环境搭建</h2><ol><li><p>点击此处<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node下载界面</a>选择适合自己电脑的版本</p></li><li><p>然后一直点下一步直到安装完毕，安装完毕后输入Win+R打开命令框</p></li><li><p>按照下面命令在命令窗口（cmd）执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">#显示版本号说明Node.js安装成功</span><br><span class="line">npm -v</span><br><span class="line">#显示版本号说明npm安装成功</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org </span><br><span class="line"># 由于服务器原因可以配置淘宝镜像来快速下载和安装需要的插件</span><br><span class="line">npm config get registry</span><br><span class="line"># 检查镜像是否配置成功</span><br></pre></td></tr></table></figure></li></ol><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>在配置好Node环境之后就可以开始安装博客系统了</p><p>1.按照下面命令在命令窗口（cmd）执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g </span><br><span class="line"><span class="comment"># 下载安装hexo</span></span><br><span class="line">hexo -v </span><br><span class="line"><span class="comment"># 检查版本号来检验是否安装成功</span></span><br></pre></td></tr></table></figure><p>2.选择你想要放博客文件的盘</p><p><img src="/img/T1.png" alt="创建blog文件"></p><p>3.执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">#创建blog文件夹来作为你的博客资源目录</span><br><span class="line">cd blog</span><br><span class="line">#进入你的博客资源目录</span><br><span class="line">npm install</span><br><span class="line">#安装hexo需要的依赖</span><br></pre></td></tr></table></figure><p>4.介绍hexo博客的文件（不操作）</p><blockquote><p>node_modules：依赖包</p><p>public：存放生成的页面    //到此步骤暂时没有public文件</p><p>theme：存放博客主题</p><p>source：文件夹下的_posts用来存放文章</p><p>_config.yml：博客的配置文件</p></blockquote><p>5.在本地服务器浏览Hexo博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">#删除静态资源文件public</span><br><span class="line">$ hexo generate</span><br><span class="line">#生成静态文件public</span><br><span class="line">$ hexo server</span><br><span class="line">#用于启动本地服务器</span><br></pre></td></tr></table></figure><p>完成后，启动浏览器访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到你的博客了</p><p><img src="/img/T2.png" alt="Hexo默认主题"></p><h2 id="安装Git-Bash及创建Github仓库"><a href="#安装Git-Bash及创建Github仓库" class="headerlink" title="安装Git Bash及创建Github仓库"></a>安装Git Bash及创建Github仓库</h2><p>使用Git可以将本地文件部署到github</p><p>1.点击此处<a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载Git Bash</a>,并检查安装情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"><span class="comment">#检查Git是否安装成功</span></span><br></pre></td></tr></table></figure><p>2.我们可以将我们的博客部署到本地服务器、购买的阿里云服务器、github或者码云上，这里我们选择github</p><ul><li>先注册<a href="https://github.com/" target="_blank" rel="noopener">Github账户</a>，再创建一个和你用户名相同的仓库，<a href="http://后面加.github.io/" target="_blank" rel="noopener">后面加.github.io</a>，只有这样，将来要部署到GitHub page的时候，才会被识别，<a href="http://也就是xxxx.github.io/" target="_blank" rel="noopener">也就是xxxx.github.io</a>，其中xxx就是你注册GitHub的用户名。</li></ul><p><img src="/img/T3.png" alt="生成SSH添加到Github"></p><ul><li>生成SSH密钥添加到Github</li></ul><p>在博客文件根目录比如：f:\blog下使用git bash here执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br><span class="line">#youremail注册GitHub的的邮箱</span><br></pre></td></tr></table></figure><p>然后一直回车知道结束，类似：</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:760461549@qq.com">760461549@qq.com</a>“</p><p>Generating public/private rsa key pair.</p><p>Enter file in which to save the key (/c/Users/hp/.ssh/id_rsa):</p><p>Enter passphrase (empty for no passphrase):</p><p>Enter same passphrase again:</p><p>Your identification has been saved in /c/Users/hp/.ssh/id_rsa.</p><p>Your public key has been saved in /c/Users/hp/.ssh/id_rsa.pub.</p><p>The key fingerprint is:</p><p>SHA256:QzOyG/Q+O6Xr8zRdr5pc7SZKyrCpkAe0O1lDXpCnIgU <a href="mailto:760461549@qq.com">760461549@qq.com</a></p><p>The key’s randomart image is:</p><p>。。。。。。</p></blockquote><p>将会在C:\Users\XXX.ssh下生成id_rsa（私钥）和id_rsa.pub(公钥)文件，打开公钥文件全选复制内容，去自己的github账户点击右上角头像选择<strong>settings</strong>，然后选择<strong>SSH Keys</strong>点<code>Add SSH Key</code>,填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，这样我们就能看到已经添加的Key。</p><ul><li><p>测试本地仓库是否连接到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>当你输入以上命令，会有一段警告代码，是正常的，输入yes即可。如：</p><blockquote><p>The authenticity of host ‘github.com (13.229.188.59)’ can’t be established.</p><p>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</p><p>Are you sure you want to continue connecting (yes/no)? yes</p><p>Warning: Permanently added ‘github.com,13.229.188.59’ (RSA) to the list of known hosts.</p></blockquote><p>如果没有提示成功，把C盘下.ssh删了重来一遍。</p></li></ul><h2 id="将项目部署到github"><a href="#将项目部署到github" class="headerlink" title="将项目部署到github"></a>将项目部署到github</h2><p>1.这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">#YourgithubName就是你的GitHub账户</span><br></pre></td></tr></table></figure><p>2.安装deploy-git才可以部署到Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>3.在博客根目录使用git bash here</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">#清除静态资源文件夹（public文件）</span><br><span class="line">hexo generate</span><br><span class="line">#生成新的静态文件（public文件），生成这个文件是根据&#x2F;source文件中的内容生成</span><br><span class="line">hexo server</span><br><span class="line">#启动本地服务器，在网址栏输入localhost:4000,查看本地更新情况</span><br><span class="line">hexo deploy</span><br><span class="line">#部署到github仓库</span><br></pre></td></tr></table></figure><p>当<code>hexo d</code>成功后，你可以在网址上输入<code>https://xxx.github.io/</code>来访问你的博客主页。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域名</title>
      <link href="/2020/09/14/DNS/"/>
      <url>/2020/09/14/DNS/</url>
      
        <content type="html"><![CDATA[<h2 id="注册和配置域名："><a href="#注册和配置域名：" class="headerlink" title="注册和配置域名："></a>注册和配置域名：</h2><ol><li><p>第一步：点击这里领券，暂时有活动，<a href="https://shimo.im/docs/TGyCppPdCdyHTKQq/" target="_blank" rel="noopener">白嫖腾讯云俩top域名各一年!</a>。</p><p>第二步：<a href="https://shimo.im/docs/TGyCppPdCdyHTKQq/" target="_blank" rel="noopener">注册域名</a></p></li><li><p>更改域名解析网址，进入万网<strong>域名控制台–&gt;域名解析–&gt;添加解析</strong></p><p>如下图：</p><p><img src="/img/T4.jpg" alt=""></p></li></ol><blockquote><p>如果出现DNS状态报错：DNS服务器错误，那就需要将域名DNS改为DNSPod,状态为正常解析才可以顺利访问网站</p><p>如下图：</p><p><img src="/img/T5.png" alt=""></p></blockquote><h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><ol><li>去博客文件夹\source下新建文本文件,命名为CNAME,不需要后缀</li><li>用文本编辑器打开并添加购买域名,如下图:</li></ol><p>​       <img src="/img/T6.png" alt=""></p><h2 id="设置项目的GitHub-Pages"><a href="#设置项目的GitHub-Pages" class="headerlink" title="设置项目的GitHub Pages"></a>设置项目的GitHub Pages</h2><ol><li><p>在 github 上面，打开 <strong>username.github.io</strong> 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：</p><p><img src="/img/T7.png" alt=""></p></li></ol><h2 id="重新部署GitHub"><a href="#重新部署GitHub" class="headerlink" title="重新部署GitHub"></a>重新部署GitHub</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">#删除public</span><br><span class="line">hexo g</span><br><span class="line">#生成新的静态文件（public文件），生成这个文件是根据&#x2F;source文件中的内容生成</span><br><span class="line">hexo d</span><br><span class="line">#部署</span><br></pre></td></tr></table></figure><p>耐心等待,一开始可能会出现电脑端可以访问但手机不能访问,需要大概十多分钟,就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 部署</title>
      <link href="/2020/09/14/coding/"/>
      <url>/2020/09/14/coding/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[^摘要]: GitHub 的分发加速网络的域名遭到 DNS 污染。由于 GitHub 的加速分发 CDN 域名 assets-cdn.github.com 遭到 DNS 污染，导致无法连接使用 GitHub 的加速分发服务器，才使得中国大陆访问速度很慢。那么现在hexo部署到coding+github上，实现境内访问coding，境外访问github</p><hr><h2 id="创建coding项目"><a href="#创建coding项目" class="headerlink" title="创建coding项目"></a>创建coding项目</h2><p>1、进入 <a href="https://coding.net/" target="_blank" rel="noopener">Coding 官网</a>点击个人版登陆，注册一个并登录，并点击创建项目</p><p>【图片】</p><p>项目名称建议和用户名一致，项目描述可以不用写</p><h2 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h2><p>[^CODING 支持使用 SSH 协议来访问 Git 仓库，提供账户 SSH 公钥和项目 SSH 公钥设置。]: </p><p>1、配置SSH公钥的方法和GitHub Pages的方式差不多，直接使用Github一样的密钥即可：</p><p>[点击头像]-&gt;[个人设置]-&gt;[SSH公钥]-&gt;[新增公钥]</p><p>【图片】</p><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h2><p>1、进入coding项目,在右下角选择连接方式，选择SSH方式（推荐），一键赋值。</p><p>【图片】</p><p>2、找到blog根目录的_config.yml，使用快捷键ctrl+end定位到最后，将部署信息改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">    github: git@github.com:XXXXXX.github.io.git&#x2F;&#x2F;GitHub的SSH地址</span><br><span class="line">    coding: git@e.coding.net:XXXXXXX.git&#x2F;&#x2F;coding的SSH地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="开启静态网站"><a href="#开启静态网站" class="headerlink" title="开启静态网站"></a>开启静态网站</h2><p>[^此步需要用到持续部署下的静态网站功能，所以需要开启该功能]: </p><p>1、进入coding项目，在左下角选择[项目设置]-&gt;[项目与成员]-&gt;[功能开关]-&gt;[持续部署]</p><p>【图片】</p><p>2、点击【立即部署】你会看到你的访问地址</p><p>到这里博客部署已经结束了，现在可以使用该地址访问自己的博客了。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>[^到这一步，必须去买域名或者看上一个博客白嫖域名]: </p><p>1、首先去 <a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNS官网</a>添加域名解析地址，将GitHub的解析路线改为境外，这样在境外就会访问GitHub，境内改为coding的访问地址。</p><p>【图片】</p><p>2、去coding项目，点击静态网站，点击右上角的【设置】，申请绑定新域名来代替网站的访问地址。注意：SSL/TLS安全证书这里有个坑,就是如果你之前已经创建绑定过github的代码仓库,那么直接生成这个证书是生成不了的,他会显示失败的状态，没有申请到 SSL 证书，当你访问你的网站时，浏览器就会提示不是安全连接。解决办法是：把GitHub的解析暂停，然后申请，最后开启GitHub的解析。最后开启强制HTTPS访问。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
